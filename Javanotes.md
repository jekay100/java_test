5/27/2014 9:43:04 PM Preface
----------
Java se:桌面应用

Java ee：企业应用

Java me：移动应用

         javac                  java
Java源代码->二进制代码（平台无关）->linux(windows)机器码
         编译器                   JVM 

如果只运行java程序，安装JRE即可。如果编写java程序，那就还需要安装JDK。

JRE=JVM+一些核心的库

实际安装中，其实JDK中本来就带有JRE，所以不用另外安装公共JRE。安装JDK即可。

Java/Bin目录：java提供的各种工具，如javac ，javap等

在安装JDK设置环境变量的时候。Path中加入的是JDK的bin目录路径。
这个路径下面是各种java工具。系统会在这些路径下查找我们所需要的工具。这个路径是给shell使用的。

还有一个classpath路径，这个路径的作用：当我们使用使用java运行二进制文件的时候，如果没有指定二进制文件(.class)的绝对路径的时候，会去这个classpath中查找对应名字的文件。同样，在我们的源程序中import了JDK中的某一个类的时候，也是去Classpath所指的目录中查找需要的编译后.class文件的。这里就要在classpath中加入JDK的lib路径。使用JDK中给我们写好编译好的各种类。
这个路径是给JVM使用的。

Java中数据类型有：
1、基本数据类型：int、double等。
2、类型：类/接口/数组/枚举类型。

Java中基本数据类型
--------------
1、整型：int（4）、short（2）、long（8）、byte（1）。表示整数。由于JVM的存在，使得在不同的机器平台上的Java程序的数据类型所占内存空间是一样大的。解决了移植性的问题。长整型数据后缀L。十六进制前缀0X，八进制前缀0。注：Java中没有无符号数。

2、浮点数：float（4）与double（8）。表示小数。float数后缀F，没有后缀默认double，也可以后缀为D。注：很少使用float，都是使用double。


3、char类型：用于表示单个的字符。表示字符常量。“”与‘’是不同的，‘’里面的表示这是一个char字符，而“”表示这里面的是一个带有字符的字符串，即使只有一个字符也是字符串。二者是不同的。\u转义表示这是一个Unicode字符。最好不要使用char类型，而是使用抽象数据类型-字符串类型。这样有利于操作。
boolean类型：注：Java中数值0不能代表false，非0也不能代表true。

Java中的数组
-------
大数值：java.math包中有两个类BigInterger和BigDecimal来处理任意长度的数字序列。
Java中没有提供运算符重载功能。


数组：
> 
	int[] a=new int[100];
	或者 int[] a=new int[]{1,2,3};

以下方法都需使用java.util.*包。这些都是针对数组这个结构的static方法。
Arrays这个类：它的作用就是操作数组这个类型。里面都是各种static方法，针对于数组这个类型的。
数组拷贝：
数组引用变量的拷贝，使两个数组变量指向同一个数组。
数组元素的拷贝，也就是制造两个数组。使用Arrays.copyOf（）这个static方法。
>
	int[] b = new int[]{1,2,3};
	int[] a = Arrays.copyOf(b);//将b数组拷贝到a数组中。

数组排序：
使用Arrays.sort()这个静态方法。这是一个快速排序法。

返回数组中数据元素的字符串形式：使用Arrays.toString()静态方法。

二分查找法：Arrays.binarySearch()静态方法。


二维数组：
>
	int[][] bal=new int[][]
	{
		{1,2,3},
		{4,5,6},
	};

遍历二维数组每一个元素：
>
	Arrays.deepToString()静态方法。

实际上对多维数组进行操作都要使用deep开头的方法。

实际上Java中没有多维数组，本质就是数组的数组。
bal数组实际上包含两个元素的数组，每个元素由三个元素组成。bal[1]引用的是二维表的第i行。这一行本身就是一个数组。
为每一行分配元素的时候：
>
	bal[2]=new int[3];将这一行当做一个元素。这样可以创建不规则数组。

>
	int[][] a=new int[10][];
	for( int n=0;n<10;n++)
	{
		a[n]=new int[n+1];
	}
或者直接：
>
	int[][] a=new int[][]{{1,2,3},{1},{2,3}};
这样创建的是一个三角形的不规则数组。不规则数组就是Java语言和其他语言的不同。

输出的时候
>
	for (int m=0;m<a.length;m++)
		for (int k=0；k<a[m].length;k++)

这样即可遍历。

或者使用foreach
>
	for (int[] row :a)
		for (int m:row)

这样亦可。

1、在java里面，数组也是一个和int、类这些东西同级的类型。他可以用于创建一个数组引用变量，也可以用于类型的转换，和所有的基本数据、类都是一模一样的。
所有的数组都是在其他的类型后面加上[]即变为数组类型。
如：String[]就是一个数组类型。int[]数组类型后面加上[]就变成了int[][]这个数组类型.
数组类型变量本质就是引用类型，实际上就是指针。数组引用本来就是一个变量。

所以，写数组的时候必须写成：int[],而不要是int a[];
Java语言是静态语言，就是说，一旦变量类型确定，就不能再修改，也就是说变量内存空间大小也不能修改了。那么java中数组的长度是不能改变的，一旦初始化完毕就恒定了。空间是固定下来的，即使元素被清空，其空间依旧保留，可以被别的元素占用。其初始化方式如下：

数组类型变量只是一个指针，如果没有将它引用到一个数组对象，那么就不能直接使用这个数组变量。也就是说数组变量必须指向一个有效的内存，也就是必须进行初始化。初始化两种：
静态初始化：
>
	int[] a=new int[]{1,2,3};//这就是静态初始化，后一个[]里面不能设置长度，因为后面的{}里面已经确定数组长度了，是一个固定的长度了，也就是数组对象定义的时候就已经静态化它的长度了。指定了数组的元素，让系统判断数组长度。
动态初始化：
>
	int[] a=new int[3];//只指定数组的长度，不指定数组的元素。后面再进行数组元素的初始化。

总之，不能即指定数组长度又指定数组元素。
>
	int a=new int[3]{1,2,3};//这是错的。因为是没有必要的。

在数组初始化之后，每一个数组元素都可以作为基本数据变量或者引用类型变量使用。
数组的使用：
数组的length属性，返回数组长度。


Java中字符串类型
---------------
1、和char不同，这是字符串类型。不是char那样的基础数据类型。使用双引号。是一个类。而不是基础数据。
>
	String Str=“hello”；//这是一个字符串。
	char c=‘a’；//这是一个字符。

获得子串：substring()方法；
>
	String substr=Str.substring(1,3);//从字符串Str中取一个子串。

拼接：“+”；
String对象中的单个字符是不能修改的，也就是说，没有函数可以直接修改一个字符串中的某一个字符。
String Str=“hello”；修改为“hellp”的方法有两个：
Str=“hellp”或者Str.substring(0,3)+”p”;而没有一个方法直接将最后一个字符进行修改。
这就是不可变字符串。
字符串相等比较，要使用equals（）或者equalsIgnoreCase（）而不是==：
因为：equal是比较字符串是否一样的。而==是比较两个字符串在内存中的位置是否相等（也就是String对象的引用变量是否相等）。当两个字符串是一样的，但是位于内存的不同处，这样使用==判定就会是false。因为内存位置不同。
例如：String Str=“hello”；
　　   if（Str==“hello”）//比较的是Str这个字符串变量指向的字符串的位置是否与后面的“hello”字符串所在的内存位置是一样的。判断会失误。

误区：关于string缓存机制
>
	String s1=new string（“hello”）；
	String s2=new string （“hello”）；//s1！=s2；因为new创建了不同的对象，s1与s2指向不同的对象。

	String s3=“hello”；
	String s4=“hello”；//s3=s4；因为JVM有一个缓存机制，专门针对字符串，在第一个hello字符串的时候，即将这个字符串对象缓存起来，到s4的时候，不再创建新的字符串对象，而是使用s3的字符串对象。

同理：
>
	String s5=“hello”；
	String s6=“he”+“llo”；//s5=s6；因为JVM有一个缓存机制，专门针对字符串，在第一个hello字符串的时候，即将这个字符串对象缓存起来，到s6的时候，二者字符串一样。所以不再创建新的字符串对象，而是使用s5的字符串对象。

但是缓存只对于常量有用，也就是说，只会对“hello”这样的有缓存。对于string s1=“hello”，
这样的，下一次使用s1是不能使用缓存的，只有使用“hello”的时候才是使用上次的缓存。
>
	String s=“good”；
	String s2=s；//没有使用缓存；
	String s3=“good”;//使用了第一次的缓存。

注：使用缓存的意思就是：他们所指向的空间是一样的。

误区：关于java的宏替换
Final修饰的变量会执行“宏替换”：
如果final修饰的变量在编译的时候就可以确定它的值（什么叫在编译的时候就知道它的值？Eg：String s=“hi”；这就是在编译的时候知道s的值。什么叫在运行的时候知道它的值？
Eg：String s1=“hi”；String s2=s1；那么，s1在编译的时候就知道它的值，而s2直到运行的时候才知道它的值。），那么，这个变量实际上是不存在的。而是在以后使用这个变量的时候直接执行“宏替换”。
这句话的意思就是：final修饰的变量如果赋予了初始值，而且这个初始值在编译的时候就已知，那么在内存中根本就不存在这个final变量，而只有它所指向的空间存在。以后使用的时候，是直接用这个初始值直接进行宏替换。
Eg：final string s3=“hello”；
　　String s4=s3;//这段代码中，变量s3并不存在，在s4语句中，需要用到s3，就是在编译到s4的时候直接执行宏替换，将“hello”置换到s4指向的空间中。也就是说，编译的时候，s4的值就已知（相当于直接在s3的位置放上“hello”）导致s4编译的时候就知道它的值。而且连“hello”这个对象也不存在，因为前面的引用变量s3已不存在了，所以再创建出对象也没有意义。
　　而在前例中，s2的值在编译的时候是未知的，直到运行的时候才知道。这就是final修饰的一个feature。
总之，如果final变量已初始化，且在编译的时候就知道其值，那么这个变量不存在了，变量所引用的对象也是不存在的。变量都不存在了其引用对象就没有存在的必要了。
Final成员变量定义时的赋值、初始化块中的赋值都不会插入到构造函数最前面，因为final成员变量在编译是已知其值，则该变量不存在。无final的一般成员变量都会插入到构造器中。
同理，static的final成员变量的定义时赋值也不会被插入到static初始化块中。无final的static的成员变量都会被插入到static初始化块中。

所谓的宏替换：就是查找、替换。

要注意：宏替换变量应该使用大写单词表示，且由多个单词连接而成，各个单词之间以下划线分隔。

>
	Final String s1=“hi”；
	Final String s2=“hello”；
	Final String s3=s1+s2；

这里创建了1个对象（“hihello”），但是只有0个变量，s1、s2、s3这3个变量不存在。因为是final的，且编译时值已知。
Java中变量
基本数据类型的变量：
int a=5；//这个5直接放置在a这个变量中，a就是基本类型变量。
引用变量：
引用变量中并不是放置着具体的内容数据，而是其引用的数据的地址。这就是引用变量。当然指针本身也是变量，放在栈中。指针所指向的内容放在堆中。

变量的声明，如，int a；double b；
变量声明之后，必须使用赋值语句进行初始化，编译器不会自己给它赋值的，这一点和C不同。没有自己初始化使用就会导致问题。Java中不区分变量的声明与定义。
Java中使用final声明常量。使用大写。且这个量只能被赋值一次。不能修改。
Java中如果要使一个常量可以被一个类中的所有方法共同使用，称之为类常量，这个量的大小不能修改，属于整个类。使用static final进行设置。
>
	static final int a=10；这个值被所有的对象所有的方法使用，且不能修改。

这个不同于单纯的static成员变量。这个static变量只是属于整个类。但是不能保证不变。

成员变量：在类中定义。
属于类的成员变量：static
属于对象的成员变量：无static
在某个方法中建立一个对象的时候，对象本身在堆中，对象的引用在栈中。
系统加载一个类，就为这个类开辟一块空间。只加载一次。
建立对象的时候，会为成员变量进行初始化。

局部变量：局部变量就是在方法中定义的变量，储存在方法栈中，必须由程序员进行初始化。不能用static进行修饰。局部变量不允许重名。
方法中的局部变量，作用域仅在方法中。
代码块中的局部变量，仅在代码块中有效。代码块：如，某个方法里面有一个括号，括号中内容就是一个代码块。代码块就是一个花括号。
形参：在整个方法中有效。

Java中没有所谓的全局变量的说法。


Java中的运算符
--------
数据的左右移位：>>与<<
在没有数据溢出的情况下，左移n位就是乘以2的n次方。右边空的地方补上0；
右移没有溢出问题。相当于右边去掉n位。右移n位就是在左边的空地方补上符号位，正数补上0，相当于除以2的n次方，然后舍去小数部分。负数就是补上1，相当于除以2的n次方，然后将小数部分补成整数。结果都比算术意义上的数小。
数字以最快的速度乘以8，就是左移3位即可。这就是提高效率的方法。

数据的无符号右移：>>>:无论数据的正负，右移都是在数据左边空地方补上0，一直补0；会将负数变为正数。


Java中基本数据之间的转换
-----
基本数据之间的转换不涉及向上或者向下造型。而是其单独独立的转换方法。
其中6个实心箭头，表示小空间向大空间转换，转换无信息丢失。3个虚箭头，表示可能有信息丢失。
基本数据类型之间的转换有两种:

一种是无信息丢失的转换，这种转换称为自动转换。例如：int a=10；double b=a；这样使用a这个int来初始化b这个double是一种类型自动转换。

第二种是有信息丢失的转换，这种转换称为强制转换。例如：double a=10.58；int b=（int）a；这样使用a这个double来初始化b这个int，由于是大空间向小空间的转换，所以需要使用强制类型的转换。当然会有空间精度的损失。截断小数部分(不是四舍五入）。

注，此处，如果想获得一个浮点数的四舍五入的结果，就使用Math.round()这个方法，获得的是一个long整型数据，如果要变成int型数据，这就需要强制类型转换。也就是int b=（int）Math.round（a）；也会有精度丢失的问题。

Java中输入输出
-----------------
A、键盘输入：

输入使用Scanner类对象进行。涉及密码输入时使用Console类对象进行（不显示密码）
系统里，System.in代表键盘。如果直接使用这个会很麻烦，一般都会对其进行包装：
包装成BufferedReader，这个更安全，而且有更完善的异常机制。
JDK1.5之后，出现Scanner，这个更方便，但在异常机制上有不足。

>
	Scanner sr = new Scanner(System.in);//这样就将键盘这个对象包装成Scanner类对象。
	while(sr.hasNextLine())//判断是否还有下一行输入。同理还可以判断是否有下一个字符的输入
	{
		System.out.println(sr.nextLine());
	}

注：多线程最困难的地方就是：出错难以调试。因为线程调用是随机的。

B、屏幕输出：
>
	System.out.println（）方法即可输出。


文件输入与输出：

A、文件读入：
读取文件的时候，使用一个File对象构造出一个Scanner对象。
这样就将一个文件内的内容读入到内存中了。
>
	Scanner in=new Scanner（new file（“myfile.txt”））；

如果文件路径中有“\”，那么需要使用转义字符。
>
	Scanner in=new Scanner（new file（“C:\\myfile.txt”））；

这样才行。in这个输入流中就是这个文件中的内容。然后就可以使用Scanner这个类的方法对这个输入流进行读取了。

B、文件写入：
>
	PrintWriter out = new PrintWriter(“myfile.txt”);//将写入流对象与文件相连接。

定位文件时可使用绝对路径:
>
	C:\\myfile\\myfile.txt;或者/home/me/myfile.txt;

当然，流最后都需要关闭。
>	
	out.close（）；


注：输入流就相当于一个管子。管子本来是空的。实际上就是表示在内存中的内容。
输入流对象这个管子里面是什么需要内容与外界的输入进行连接，这个流对象在哪里显示需要与外界的显示输出连接起来。也就是说，一个流就是内存中的一块空间。需要在两端与外界连接。这才是流的特征，有来源有出口。

和控制台的输入相连接：
>
	Scanner in=new Scanner(System.in)；//这是将输入流对象in与系统控制台输入进行连接。
	Console inc=System.console();//这是将输入流对象inc与系统密码输入相连接。

与控制台的输出相连接：
>
	String name=in.nextLine();//将输入流对象与name这个输出的东西进行连接。	

任何一个输入、输出流对象都需要在两端进行连接，然后就可以使用。只不过流对象的功能不同。各种不同的流对象都是针对不同的两端的内容的。两端内容不同，使用不同的流对象。

Java中的块，一个变量的有效范围就是一个块。但是嵌套的块中，变量不会覆盖块外的变量，这一点和C++不同。



Java中的语句
-------

选择语句：
>
	if（）……else if（）……else……
多重选择：
>
	switch（）case1：……break；case2：……break；default：……；一般很少使用switch。

循环语句：

不确定循环：
>
	while（）……do……；do……while（）；
确定循环：
>
	for循环，for循环是支持迭代的通用结构。利用每次迭代之后更新的计数器或者类似的变量来控制迭代次数。

Foreach 循环：
>
	for（variable：collection）statement；

Java类之间的关系
-----------

1、依赖（use a）：一个类的方法中操作了另一个类的对象，这就是依赖的关系。例如类A的某个方法中使用了B类对象作为局部变量，这就是依赖。
应该将互相依赖的类减至最少。这就是使A类不知道B类的存在，意味着B类的改变不会导致A类产生bug。这样就是让类之间的耦合度减小。

2、聚合（has a）：一个类A中的成员变量包括B类对象，这就是聚合关系。也就是A类对象包含B类对象。

3、继承（is a）：A类由B类继承而来。特殊与一般的关系。包含B类中的方法。


Java中的引用
---------
Java中的引用类似与C++中的指针。

一个Java源程序中，只能有一个public类（也就是只能是main那个函数所在的类是public，其他的所有类都不能）。但可以有任意个非public类。


Java中的编译与文档生成、汇编
------------------------
Java编译：
Java中可将各个类放在不同的源文件中，如:test.java与testdrive.java.

这样编译的时候，可以使用通配符：
>
	javac test*.java

这样所有的文件都被编译成.class文件。

编译public类文件:
>
	javac testdrive.java

这样编译器会先导入testdrive类，然后自动搜索需要的类，在编译的时候，会首先查找test.class文件，如果没有就会查找test.java文件并编译它。如果.java文件比.class文件新，就会重新编译.java文件。这就相当于Java编译器内置了make工具。

相对路径：不以盘符开始的路径。不唯一的。所以要使用相对路径就需要在一个基础路径才可以。相对路径的基础路径就是当前路径，就是现在操作的路径。

绝对路径：以盘符开始的路径。唯一的确定的。

Javac命令用于编译；
Java命令用于运行；
Javadoc命令用于从源文件中提取文档注释以生成API文档：
命令：
>
	javadoc -d 生成API放置目录路径 java源文件； 

然后去API文档目录中查看index.html文档即可。

javac将程序编译都一个文件夹中需要先自己创建一个文件夹。这个文件夹对应整个工程。里面的都是一个个程序编译出来的包（package），package放在这个自己创建的文件夹中(这个工程的文件夹）。

也可以不直接创建一个文件夹：而是编译时使用：
>
	javac -d .\ java源文件  // .\表示放在本目录下创建文件夹。文件夹中的包和源文件中的package层次相对应


但是javadoc提取API是不需要自己创建一个对应文件夹的，程序会自己创建一个。


javap 命令的使用：
>
	javap -c 类名：

java中的反射库：用于产生程序执行过程的汇编代码。

java的return
----------
访问器方法的`return`不能是可变变量的引用。  
因为返回可变变量的引用之后，就会导致以这个访问器方法做左值的时候，就会在类外修改了类的`private`成员变量的值。这就破坏了封装原则了。
那么访问器`return`的时候，应该返回可变变量的`clone()`才行。或者返回final变量。

java中final关键字
-----------------
1、final修饰变量（*成员变量*（类拥有变量与实例拥有变量）与局部变量（方法内局部变量与块内局部变量））  

final修饰符大部分用于基本数据类型，或者不可变类的域（类中的每一个方法都不改变该成员变量）。如果是用于一个类成员变量（也就是非基本数据类型成员变量），就会导致混乱，因为在一个类中使用final类成员变量，只说明这个类成员变量的引用是不变的，而不说明这个对象本身时不变的，只是引用不变而已。
所以final修饰符最好不要使用在非基本数据类型成员变量上。
final成员变量表示这个变量是不能被修改的。

A、final修饰成员变量
必须人工进行初始化，初始化的位置：
定义成员变量时、
初始化块（普通初始化块与static初始化块）、
构造函数。

普通方法不允许为final成员变量赋值。final成员变量只能在以上三个位置进行初始化且只能在一个地方赋值。因为他们前两个实际上都是插入到构造器中来发挥作用的，所以三者都是平等的地位。都可以对final成员进行初始化。

B、final修饰局部变量	
必须人工初始化，无论是否是final局部变量。
局部变量加了final之后，以后再也不能修改其值了。

要注意final变量的工作方式与普通变量是不同的，见java中字符串类型中说明的final变量的工作原理。

2、`final`修饰符用于类方法或者整个类，表示这个类或者方法不能被继承或重写了。  
非`final`类中可有非`final`方法和`final`方法，其中的非`final`方法可有被继承重写。但是`final`方法不能被重写。  
`final`类中所有的方法都是默认为`final`的，也就是说，`final`类中所有方法都不可被重写。但是不说明那些成员变量是`final`的（`final`成员变量表明成员变量不变）。
也就是说`final`成员变量可以设置为`public`，因为它已不能被修改了，为一常量。

Java中static关键字
-----------------
`static`就是一个标志，不是什么静态的意思。  
`static`成员变量和`static`成员方法还有`static`初始化块。与类共存亡。  
`static`成员变量属于整个类，所有对象共享。`static`成员变量可以在声明定义的时候即赋值，也可以在`static`代码块中进行赋初值，但是不能在构造函数中赋初值。  
如果是`final static`常量，能在成员常量定义的时候赋初值。也能等到在`static`初始化块里面赋初值。因为最终也是要插入到`static`初始化块的。    
`static`成员变量使用的较少。但是`static`成员常量用的较多，也就是`static final`成员常量。全类共享，且不变。  
`static`成员方法是不能对对象进行操作的，只能对类共享的成员变量进行操作。不需要对象，也就是`static`方法没有`this`这个隐藏参数。  
以下两种情况下需要使用`static`成员方法。  
1. 当这个方法不需要使用对象的状态的时候，也就是这个方法的所有的参数都是显式提供的，而不需要隐式提供的`this`。  
2. 这个方法只需要访问类的`static`成员变量，不需要访问非`static`成员变量。当有类但是没有创建对象的时候，可以通过类直接使用`static field`或者方法。

静态方法的还有一个用处就是：`Factory`方法。用于产生不同风格的格式对象。

在同一个类中：
`static`成员不能访问非`static`成员（包括成员变量与方法）。  
`this`、`super`都不能出现在`static`成员中（如，不能出现在`static`方法中）；
这里的`static`成员包括：`static`方法、`static`初始化块、`static field`但不包括构造器（也就是说，`static`成员可以调用所有的构造器，因为构造器根本就没有`static`修饰这回事儿）。
也就是说，`static`初始化块里面都不能出现属于实例的非`static`的东西。  
总之一句话，类拥有的东西不能碰对象拥有的东西，也就是说，抽象、集体的东西不能碰具体、个人的东西。但前提是：在同一个类中。
>
	Static main方法都不能访问同一个类中的非static field。
	Public class m
	{
		int a=10；
		Public static void main（String[] args）
		{
		System.out.println（a）;//这是错的，在同一个类中，本类的static成员不能访问本类的非static成员。
		}
	}
`static`的东西在导入这个类的时候即导入。是最先导入的。  
`main`方法也是一个`static`方法。
任何一个类都可以拥有它自己的main方法，这是常用的对类进行单元测试的技巧。
如果要单元测试这个类，可以直接`javac employee`即可。这样就会执行`employee`这个类的`main`方法。

Java中abstract关键字
------------------
`abstract`类：  
`abstract`类特点：有得有失  
得：可以拥有抽象方法。因为普通类中不能有抽象方法，只有抽象类中才可以有抽象方法。所以，一个类中有了抽象方法就一定是抽象类。  
失：不能创建实例。  
误区：  
1. 其他的和普通方法都是一样的。同样有各种`field`（`static`与非`static`），各种构造器，各种初始化块（`static`与非`static`的）。  
2. 抽象类可以没有抽象方法。但这种抽象类依旧不能创建实例。

但是，既然抽象类无法创建实例，那么，我们还需要抽象类的实例方法、变量（非`static`方法与非`static`成员变量）和构造器干什么？  
Answer：  
1、抽象类的构造器是用于供其子类调用以进行父类成员变量的初始化。  
2、抽象类的各种非`static`成员方法是用于被子类重写(`override`)。或者被子类直接调用(直接使用`super`即可)。非`static`成员方法中，抽象成员方法用于被子类重写。非抽象成员方法用于被子类调用（父类、子类都拥有这些方法）。

`abstract`方法:  
说明这个方法既不能被本类调用又不能被本类的实例调用，只是占了一个坑，留给子类来填。使用`abstract`修饰，且没有方法体。  
`abstract`不能与`final`同时出现：`abstract`表明必须继承重写，`final`表明不能重写,矛盾.  
`abstract`不能与`static`同时出现：`abstract`表明这个方法不能被类调用也不能被对象调用，必须被继承重写之后才可以被使用。而`static`表面这个方法可以被本类调用,矛盾。
`abstract`不能与`private`同时出现：`private`方法不能被覆盖（`private`无法被子类调用识别，更不用谈覆盖重写了）。`abstract`方法必须被覆盖。所以二者矛盾。  
`abstract`方法可能不能被子类重写。当子类在另外的包中的时候，就不能覆盖父类中`abstract`方法。因为没有明确写访问权限的时候，父类中`abstract`方法不能被位于不同包中的子类重写。



Java中传值
-----------
java方法传递值，都是按照值传递，也就是复制传递的。只有这一种方法。
只是复制传递过来的有两种：
基本数据类型、
对象的引用。
>
	int a=10；
	p.f（a）；//不管这个方法的具体实现。这样方法调用完之后，a的值依旧是10；因为只是一个复制拷贝被传递进来而已。

也就是说：一个方法不可能修改一个基本数据类型的参数。
但是，以一个对象引用作为参数就不同了，可以很方便得修改对象引用所对应的实际对象，不能修改这个对象的引用，但是可以通过对象引用来修改对象本身。

总之，记住，java方法传参只有一种，那就是通过复制传值，可能传递的是基本数据，也可能传递的是对象的引用变量。

Java中构造
------------------
构造器：
特殊的方法，无需返回值。
构造器的作用：并不是用于创建对象的，而是用于进行初始化的。创建对象是new的功能。
构造器的重载：完全类似于普通方法的重载。
如果构造函数中没有显式初始化成员变量，编译器就会自己给初始化，但是实际中程序员都要自己进行初始化。
但是方法中的局部变量和类成员变量是不同的，局部变量是不会被编译器给自动初始化的。所以，方法中的局部变量必须被显式初始化。
一个成员变量在被构造函数构造之前，也就是这个成员变量定义的时候，就可以赋初值，这种用法在希望该类的每一个对象都拥有相同这个成员变量值的时候可以使用。
Java，初始化时，先初始化成员变量的定义部分赋值，然后执行初始化块中的内容，再执行构造函数中的内容。 

当一个成员变量的初始化很复杂（例如，是一个对象，需要好几个语句进行初始化赋值，这时候，就不能使用成员变量时的初始化赋初值。只能在初始化块中或者构造函数中进行赋初值。对于static成员变量定义时赋初值或者static构造块，它们执行顺序与定义的顺序是一样，也就是说，如果static构造块在前面，static成员变量初始化赋值初始化在后面，那么在使用这个类的时候，即进行初始化。总之，所以static的东西在非static的东西之前进行初始化。是所有的都是如此。非static是在创建对象的时候才进行初始化。static的成员变量在创建对象之前就初始化了。因为他是属于整个类的东西。
类所在目录路径必须与类代码前面的包名相同，这是规定。 

Java中继承
-----------------
Java中所以继承都是公有继承。 
 
尽管子类可以继承拥有父类中所有的成员变量与方法，但是，子类依旧不能使用父类中的私有成员变量与方法。只有父类才能访问他自己的私有成分。子类要使用父类的私有部分也只能通过父类中的public成员方法才行。Super.f（）；这样才行。 
 
在子类的构造函数中，C++中是通过构造列表来构造初始化父类中的成员变量的。而Java中是通过在子类的构造函数中最先调用父类的构造函数来对父类中成员变量进行初始化（super（））构造。
 
子类中可以增加成员变量，成员方法。还可以覆盖父类的方法， 但不能覆盖父类中的成员变量。

Java中的继承：是单继承。但可以有n个间接父类。
注：
Java中的继承于现实中的继承是不同的。
现实中继承：对象与对象之间的关系。如：父亲与儿子的关系，这是对象之间的继承。
Java中的继承：类与类之间的关系。父亲与儿子之间的关系并不是java中所指的继承。
Java中的继承是：从一般到特殊的关系。是“is-a”的关系。就是扩展、延伸的意思。

子类继承父类：在父类中的5个部分中，子类可以获得父类所有的属性与方法（包括private的，但是不能在子类中访问，但确实是有），但是不能获得父类的构造器、初始化块、内部类等东西。


 
Java中数组与Arraylist的区别
---------------
Java中的数组实际上就是所谓的静态数组。就是在定义这个数组的时侯即说明了数组的长度以后不能修改。 
>
	int［］ m＝new int［］；

> 或者
> 	
	Emploree[] staff=new Emploree[3];
    m［0］＝1； 
    m［1］＝2；//这样即设定了数组m的长度，即使数组元素可以修改，但是数组长度不能修改了。只能为2。 
 
Arraylist就是一个泛型类。类似与C++中的vector模板。
Java中的Arraylist就是所谓的动态数组。在定义这个对象的时候并未决定容器长度，长度可以动态改变。 
取数组中的元素使用[]即可，但是由于arraylist并没有像c++中vector那样重载[]，所以，要是使用显式方法get（）与set（）来获得、存取数据元素。

这就是它们之间的区别。

Arraylist中元素访问不方便，而数组规模不能扩充。所以可以采用一个方式将二者的长处结合起来，这样就可以使得即能扩充规模，又能方便地访问数据。
这种方法就是：将数据储存于arraylist中之后，将这个arraylist转换为一个数组。这样就能达到目的。就是对arraylist对象调用toArray方法，就会产生一个数组对象。
这个arraylist就是一个数组列表，相当于vector。如果插入删除较多，就会导致效率下降，这时候就应该使用linklist数据，就是链表。这样有利于插入和删除。	

Arraylist对象都有注明存储类型。

Java中的多态
-------------
在C++中，如果要实现某个函数的多态进行动态绑定，就需要将相应的方法设为虚函数。
但是在Java中，要实现某个函数的多态动态绑定，不需要设为虚函数，Java中并没有特别指出虚函数，默认所有的函数都是虚函数。也就是说，任何函数都可以实现动态绑定实现多态，而不需特殊声明。这就是C++和Java中的区别。
当然，如果不想让这个方法实现多态动态绑定，可以将这个方法标为final的即可。这样，这个方法就不可以被重写，这样也就没有动态绑定的了。

另注意辨析Java中的final关键词，表示这个函数不能被重写。
Final类不能被继承了。Final类中所有方法都是final的。
Java中没有多重继承。Java中的置换法则，就是程序中任何的父类对象都可以使用子类对象进行置换。
如：employee e=new manager（）；employee这个父对象可以使用manager这个子类对象进行置换。

在Java中，默认对象变量是多态的，也就是说，一个父类变量既可以引用一个父类对象，也可以引用一个子类对象。如上文父类变量e既可以引用一个父类对象employee对象，也可以引用一个manager类对象。

重要的问题，动态绑定中，可以通过父类变量引用子类对象，多态引用之后，父类变量会自动使用子类中重写的方法，也就是说，如果子类重写了父类中的方法，那么会自动使用子类重写的那个方法。但是，如果某个方法在父类中是没有的而是在子类中新加入的，那么就不能使用父类变量来调用这个方法，而只能使用父类中已有的方法。也就是说，尽管有多态的存在，父类变量依旧只能使用父类中拥有的方法（子类中新加入的方法父类是不能使用的），子类对象才能使用他自己拥有的方法（包括子类中新加入的方法）。

注意：任何数组里面放的是类变量，而不是变量所引用的类对象。

Java中的方法签名：方法的名字和参数列表，但是函数的返回类型不是方法的签名。以前，在子类覆盖父类方法中，子类方法返回类型必须与父类相同，现在允许子类返回父类的子类类型。也就是说，manager类某一个覆盖父类的方法的返回值可以是manager类，也可以是employee类的。以前是必须保证manager覆盖的方法的返回值必须与父类的相同。现在可以返回父类子类类型。
当然，覆盖方法时，覆盖方法名字与参数列表是不能改变的，必须与父类的那个方法是一样的。

Private方法不能覆盖。Static也不用覆盖，final方法不能覆盖。这三种方法都是静态绑定。

多态实现的原理就是，虚拟机会搜索类变量实际类型的方法表，以确定实际上该使用哪个类的方法。然后即可以调用这个实际的方法了。这样就实现了动态绑定。

注意，final类中所有的方法默认是final的，但不说明成员变量是final的。
非final类中可以有final成员方法和非final成员方法。

将一个类或者方法设为final的原因在于：他们不会在子类中改变语义。

Java中类型转换
--------------------

关于类型转换的问题。
基础数据类型：
短空间向长空间转换：这样可以直接转换，因为不涉及精度损失：
int a=10；double b=a；//这样是没有问题的。
B、长空间向短空间的转换：
>
    double b=10.0；int a=b；//这里必须使用强制转换，因为涉及精度损失。会产生截断。

非基础数据类型。也就是类对象变量之间的转换。
他们涉及的是向上、向下造型。//manager继承自employee对象。
子类变量向父类变量的转变：这就是向上造型。
>
	Employee e=new manager（） ；这样就是向上造型。

B、父类变量向子类变量的转变：这是向下造型，需要类型强制转换。
>	
	Manager k=new manager（）；//这样建立一个子类变量k
    Employee e =k；//这样是向上造型，将子类对象转换为父类对象，这样可以实现多态，但是转换后的父类变量e并不能调用子类中独有的方法f（），只能调用父子类都有的方法。
	Manager m=（manager）e；//这样就是向下造型。类型强制转换。将向上造型获得的父类变量还原成他原来的类型。
	m.f（）;//这样可以通过向下造型获得的子类对象来调用子类独有的方法。`

但是这样的转换往往并不成功（这是因为这种向下造型只对于那些事通过向上造型获得的父类变量才有效，也就是说向下造型值能用于还原向上造型得到的父类变量，而不能转换任意的父类变量）。所以需要事先检查到底是都可以转换，也就是：
>
	if（e instanceof manager）
	{ 
		Manager m=（manager）e；
	}

一般来说，向下转换是很少使用的，使用的时候一般用于：父类对象要使用子类的方法的时候，这个强制转换的作用就是将已经被向上造型的类变量还原成他原来的类型。也就是说，以前由向上造型从manager变为employee，那么转换之后就不再能通过转换后的employee变量来调用manager独有的方法了（就是manager自己增加的方法），这个动态绑定导致只能通过父类变量调用父子都拥有的方法，而不能调用子类独有增加的方法。如果，转换后的这个父类变量想要使用子类自己独有的方法（注意，这个时候，这个父类变量是通过向上造型获得的，他实际上引用的是子类变量，只不过他不能使用子类独有的方法而已，只能使用父子类都有的方法），这个时候就可以通过这个向下造型将向上造型获得的父类变量转换为子类变量。然后通过这个子类变量来使用它独有的那些方法。
Java中需要将向下造型与类型判断(isinstanceof)一起结合。


Java中类型转换有这么几种：
自动类型转换：
基本数据类型之间的短空间向长空间的数据类型转换。
类之间的子类向父类的向上造型。
自动转换能否完成的决定因素是：被转换的数是否在转换目标的范围之内？
>
	double i =5；//5这个int在double的范围之内，所以可以自动转换。
	Byte b=5；//5这个int在byte的范围之内，所以可以自动转换。不同强制转换。

强制类型转换：
基本数据类型之间的长空间向短空间的数据类型转换。
类之间的父类想子类的向下造型（当然是用于恢复被向上转换的子类型）。

实际上出来基本数据和类之间的类型转换，还有一种就是表达式类型的自动提升。
所谓的表达式的类型：就是表达式中最高级的运算元素的类型。如int+double：结果就是double型。
>
	int a=5+5.5;//这样就是错误的，因为右边的表达式结果是double型，要转换成左边的int型就需要强制转换，而不能直接转换，精度会有损失所以是不能自动转换的。
如果需要使用，就需要将右边表达式结果进行强制转换：
>
	int a=(int)(5+5.5);

这样才是可以的，这样就是表达式类型的提升。

此处一个注意点：任何的表达式结果的类型都是其所有的运算因子最高的类型。即使运算结果是其他的类型，也必须是运算式中的最高级。
例如：int a=10/4;//这是正确的，因为10/4这个右边的表达式的结果是2，因为10与4都是int型，所以，10/4的结果也必须是int型，即使算术上结果是2.5，那也只能得到2这个int型。所以这个式子是没有问题的。
所以来说：一个表达式的结果的数据类型早已被它的运算元素决定了，而不在于实际的算术运算的结果。


Null不能赋值给基本类型变量，只能赋给引用变量。

强类型语言更加健壮。

Java中的抽象类
-----------------
C++中多态是通过抽象类实现的。而Java不是。
实际上Java中也有抽象成员函数。但是Java中的抽象类与抽象成员函数时用于继承的。也就是，抽象函数不用实现。留给子类进行实现。
 抽象方法充当占位的作用。
抽象类不能实例化。也就是不能创建一个抽象类对象。
但是可以创建一个抽象类变量，只是这个变量不能引用抽象类对象，可以引用非抽象类对象（如子类对象）。这也就是说抽象类变量可以作为一个多态接口。通过抽象类变量来调用具体的子类变量的方法。因为可以创建抽象类变量，只是不能创建抽象类对象而已。

只要有一个抽象方法的类就必须声明为抽象类。
没有一个抽象方法的类也可以声明为抽象类。

C++与Java中关键词对比：
Java中final=const；但是添加了不能继承的特性。
Java中static=static；全类共有的方法与变量。
Java中abstract=abstract；但是去掉了控制多态性的特性。

Java控制可见性：
Private：仅对本类可见。
Public：对所有类可见。
Protected：对本包和所有子类可见（这一点和C++不同）
默认：也就是不人工设置可见性，这个默认对本包可见。


Java中所有的类都是Object类的子类。所以，可以使用Object 类来引用所有的类对象（包括任何的数组）。这是向上造型。


Java中抽象类的作用，抽象关键词见Java中abstract关键字。
主要是一个设计模式相联系：模板模式。Java中共有23中设计模式。
当在一个类中某个方法暂时不能被实现时，可以留给子类进行实现。这时候，就需要在父类中将这个方法设为抽象方法，同时这个类也是抽象类。
这个时候，在子类中，要么将父类中全部抽象方法都给实现了，要么子类继续当一个抽象类（因为只要子类中有一个抽象方法，子类就必须是抽象类）。

抽象类不能创建对象，但是抽象类引用变量可以引用非抽象类对象实例。
>
	Abstract class A；
	Class B extends A；//B中重写了A中的抽象方法。
	A a=new B（）；//A是抽象类，不能创建实例。B不是抽象类。A的引用变量可以引用B类对象实例。

然后就可以使用a这个引用来调用B中重写的A的抽象方法，这就模板模式的工作原理。

Java的Object类中的常用方法
----------------------
Equal方法：
判断对象相等的方法，比较对象是否相等。
对于对象而言，使用“==”判等，只是判断对象的引用变量是否相等，而不是判断对象本身是否相等。
所以要重写equal方法来对对象判等。

注：使用==判断基本数据类型的时候，只会判断数据实际的大小，而不会比较数据的类型。
Eg：
int a=10；
double =10.0;
a==b;//对的。
　
HashCode方法：用于返回对象的散列码。
散列码是由一个对象导出的一个整数值，没有规律。对象不同，他们所对应的散列码（hashcode）也是不同的。这个散列码就是对象的内存地址。相等对象返回相同的散列码。
计算散列码的算法方法在Object类中，每一个子类计算对象散列码的算法都来自于此。

toString方法：用于返回对象的描述性字符串。
Object类中有toString方法，我们可以自己定义自己的toObject方法。
注意，equal、toString，hashCode这些方法都是从Object继承下来的类才有的。对于基本数据类型如、int这些是没有的。因为他们不是对象。只有对象才能使用这些方法。
toString方法是非常有用的调试方法。类库中许多类都拥有自己的toString方法。
Tostring方法有一个标准写法。程序员自己重写的用于调试。

Clone方法，用于复制一个新的对象，重新分配空间。创建对象的副本。

getClass，返回类的情况。
Getname，返回类的名称。
Getsuperclass，返回超类的情况。

Java中的包装类
-------------
由于java是面向对象语言，所以java中的一切都是对象。所有的类都是object类的子类。
但是历史遗留下来的8个基本数据类型是例外（他们是从C来的）。不能当成对象来使用。
因此java为这8个基本类型提供包装器，将他们包装成类。本质依旧是基本数据类型，只是被包装成类。 	

Java中存在一个对象包装器，当需要将一个基本数据类型转换为一个对象的时候，就需要使用对象包装器来将基本数据类型装换为一个对象。实际上所有的基本数据类型都存在一个对应的类。
例如：
某个arraylist中只能存储Interger这种对象，而不能存放基本数据类型，这时候就需要将int型数据包装成interger对象。
Interger i=new interger（2）；//这样就将一个基本数据包装成i这个interger对象。这称为自动打包。现在不需要这样人工手动进行包装了，JDK会自动进行包装。
可以直接：Integer i=2；即可。
但是打包成对象之后，会导致操作效率下降。

当将一个对象赋给一个基本数据类型的时候，会自动进行解包。
int a=i；//这样就将一个对象进行解包了。
相当于：int a=i.intvalue();//现在可以自动转换，不需要再使用函数进行人工转换了。
另外，在对对象进行增、减操作的时候，也会自动进行解包，增减操作之后再进行打包。
i++；//先解包，然后对里面的基本数据进行增减操作，然后再打包。

基本数据“==”判等的时候，是判断数据大小的。
数据包装器“==”判等的时候，是判断类变量所指向的内存位置是否相等。
那么在数据包装之后的类对象进行判等就需要使用equal方法进行。
打包和拆包是编译器的事，不是虚拟机的事。编译器在生成打包后的类的时候，会生成一些字节码，加入必要的方法调用。虚拟机只是执行这些字节码。
使用基本数据包装器的好处是：可以将一些需要使用的基本方法放在对象中，因为基本数据类型中是不能自己添加方法的。所以包装成对象之后，就可以添加自己想要的方法。
 例如：将一个数值字符串转换成基本数据类型。这样就可以在包装后的类中添加必要的方法以实现这一点。
包装器对象时不可变的，也就是说基本数据类型被包装之后，就不能够被修改了。这个对象里面的内容就固定了。

Java基本类型的包装类。
byte->Byte;
short->Short;
……

在JDK1.5之后，基本类型的数据值可以直接当成对象，被类型引用变量引用。因为JDK1.5之后提供了自动装箱、解包功能，将基本数据类型数据包装成对象（被当成它的包装类使用）。也可见对象当成它的基本数据类型使用。
Eg：
Object a=3；//3这个基本数据类型值直接被a这个引用变量引用。
Integer a=2；//这也是对的，会自动将2这个基本数据包装成Integer类型。

还会自动将包装类的对象解包成基本数据。这是没有问题的。
int b=a；//这样自动将a这个对象解包成int这个基本数据类型。

由于包装和解包极其方便，所以现在很少直接使用int、double这种基本数据类型。而是使用包装的类。因为包装类使用更加方便。

对于所有的基本类型包装类，在1.7之后，添加了一个新的方法static compare（）；
Eg：
compare（Double a，Double b）：

Java中的方法栈及内存模型
-------------
任何一个方法里面声明的变量，都是存放在这个方法的栈里面，有很多的栈，每个方法都有自己的栈。方法运行结束就会释放这块内存。栈内存只是一个临时内存。
基本数据类型变量和变量值都是放在方法的栈中。
引用类型变量也是放在方法的栈中，这个变量引用的对象是放在堆中的。每个Java虚拟机只有一个堆内存，一般默认是64M，但是可以在运行java程序的时候进行设置。只要JVM不退出，堆内存就一直存在。Java -Xms256：就是设置为256M。堆内存中的对象只能通过引用来访问。
例如：数组类型变量存放在栈中，数组这个对象本身时存放在堆中的。
Java中并没有真正意义上的数组。所谓的二维数组，只是若干数组引用变量构成的一个新的数组。

二维数组的特殊之处：内含的一维数组的首地址也就是一维数组的引用变量被存放在堆内存中。然后这个引用变量指向堆中的另一块空间中的数组。而不是如一维数组中的那样放在栈中，所以：一个引用并不一定是放在栈中，还有可能放在堆中。

Eg：二维数组的使用：
int[][] a=new int[4][];
a[0]=new int[]{1,2};//一维数组的引用。依次确定各维数组地址。a[0]就是一个引用变量。指向一个数组。
…… 
总之，N维数组的元素就是n-1维数组的引用变量。如此递归，一直向下引用。


操作数组的Arrays类，这是一个工具类，用于操作数组。
都是一些static方法，Arrays.search(a,5);//在数组a中查找一个数据5

数组引用变量被从栈中销毁之后，数组对象本身时不一定会立刻从堆中销毁（不会随着数组引用变量而回收）。
而是依靠GC（垃圾回收线程），来自动销毁堆内存中的对象。它的原理就是：GC会自动记录堆内存中对象是否有引用变量引用它。会在合适的时候回收该堆内存的位置。 

内存泄露：内存被占用，但是没有被收回，导致内存泄露。
还有一种情况：内存还需要继续被使用，就直接收回了这个内存。
这两种是编程中常见的内存问题。C语言中尤为常见。Java中概率小很多。
Java中引用实际上就是指针。只不顾对指针进行了包装，使其使用更为安全。

char ch =”0”;
int num=ch;//这样num就是48；是一个int，可以自动转换的。如果在数组中第0个元素对应为为“0”；那么转换的时候就是num-48，这样才行。

Java中对象的内存管理步骤：
在堆中开辟一块permenant空间，用于储存类的static部分。
创建对象引用变量，放在栈中。
创建引用的对象本身，这个对象放在堆中，对象自有的（不是类所有的）成员变量也放在这个对象中，就是在堆中。
调用方法时，方法中的局部变量放在栈中。

Java中类的原型
-----------------
一个类中最多有5个部分：

    修饰符 class 类名
    {
    　　//0-n个field定义；
    　　//0-n个方法定义；
    　　//0-n个构造器定义；
    　　//初始化块（static块）……
    　　//内部类、内部接口、枚举等。……
    }
如果多于5个即为错误的类。


Field定义：注：[]表示可以省略；
[修饰符]+类型+field名+[=默认值];
修饰符：public|protected|private, static，final。
类型：基本数据类型，数组，类（JDK中的类或者自定义类），接口，枚举。

方法定义：
[修饰符]+返回值类型+方法名(0-n个参数)
{
……
}
修饰符：public|protected|private, static，abstract|final。Abstract与final相反。
返回值：基本数据类型，数组，类（JDK中的类或者自定义类），接口，枚举，void。


构造器定义：
[修饰符]+构造器名（0-n个参数）
{
……
}
修饰符：public|protected|private;
构造器的作用：初始化类的实例，也就是初始化对象。

初始化块：
1、[static]
{
　　//可执行语句。
　　//类初始化块。专门用于初始化类拥有的成员变量，也就是static成员变量。
}

Eg：
`Public class A
{
　　static int age；
　　
　　Static
　　{
　　Age=10；//类初始化块。
　　}
}`


2、如果没有static，就是实例初始化块。
{
　　//可执行语句。
　　//实例初始化块。专门用于初始化实例拥有的成员变量，也就是非static成员变量。
}
Eg：
Public class A
{
　　int age；
　　{
　　Age=10；//实例初始化块。
　　}
}
　　
注：初始化块是自动调用的。不能被认为调用。

为什么要定义初始化块？
对于一个类而言，会有许多个构造器，这些构造器中互相有一些重复的初始化语句，这样就会加大代码量。所以，可以将这些重复的初始化语句放在一起，构成一个初始化块，让这些重复的初始化语句对于每一个对象或者类都自动执行。就可以减小代码量。这就是初始化语句的作用。
但是：只有处于构造器中前面的初始化语句才可以放在初始化块中，而不是跳跃式放入初始化语句。

Java中允许多个实例初始化块，但没有意义！


什么是实例初始化块的工作原理？
在编译中，所有的实例初始化块都会被还原到相应的构造器中，然后直接调用构造器即可。因此在汇编代码中并没有初始化块的痕迹。
同时，要注意的是：在声明成员变量时赋给的成员变量的值也是不会在汇编代码中留下痕迹的。也就是说，声明成员变量是赋给成员变量的初始值也会在汇编的时候直接插入到相应的构造函数中。

总之，初始化块中对成员变量赋值与成员变量声明时所赋的值都是一种假象（不包括static初始化块和static成员变量）。他们都是在编译的时候被直接插入到构造函数中（放在构造器的最前面。初始化块与成员变量赋值在构造器中具体哪一个放在前面决定于代码中哪一个放在前面，放在前面的在构造器中放在前面。），然后通过调用构造函数来进行起作用的。


类初始化块的工作原理？
类初始化块在类被加载的时候执行。对类拥有的field进行初始化。不会对所有的对象都执行，总共只执行一次。

static成员变量声明时赋值会在编译的时候插入到static初始化块中，然后执行static初始化块即可。插入位置与在代码中相对位置有关。这一点是不同于实例初始化块（实例成员变量和实例初始化块都一起插入到构造函数中）

那么初始化块代码在什么时候执行？
实例初始化块在每次调用构造器之前自动执行。而且实例初始化块与实例成员变量会在编译时直接插入到构造器中最前面，然后直接执行构造器即可。
类初始化块在类加载的时候就执行。而且类成员变量会被直接插入到类初始化块中，直接执行类初始化块即可。


Static:实际上并不是静态的意思。也不是公共的意思。而是一个标志，表明这个成员变量是属于这个类的。而不是属于某个对象。
在创建类对象之前，就将整个类加载到内存中，加载过程中，就将属于这个类自己的东西加载到堆中的某一个区域（叫做：permanent区）。也就是说，还没有分配对象的空间（构造器启动之前），就已经为static成员分配堆中的空间了。
总之：static修饰的属性、方法根本就不属于对象的，就是说，任何一个对象根本就没有这个static属性、方法。即使允许通过对象来访问static属性、方法。但是这只是一个语言设计上的错误、缺陷。实际上这个static属性、方法根本就不属于任何对象。只属于类。考试的时候常有这样的题目作陷阱。
　　
static方法也是属于这个类的。而不是属于某一个对象。也就是说，永远不要用某一个对象来调用static方法，因为对象根本就不永远这个static方法。

注：只要用到了一个类，那么就会初始化static部分，
Eg：person p；//这样就是用到了person这个类，就是加载了person这个类，该类拥有的成员变量就会进行初始化。
而且初始化是从顶层向下层的顺序进行的。

Java中所有的引用如果是被JVM初始化，那么全部被初始化为null；没有指向任何的有效内存区。
类属性、方法（static修饰）与实例属性、方法（非static修饰）是不一样的。

注意：永远都不要使用对象来调用Static修饰的类方法、类属性。如果别人的程序中有使用对象来调用static修饰的类方法、类属性时，首先就要把这个对象换成类。然后再继续看。
这种题目经常出现在面试考题中，所以要注意这个问题。一定要使用类来调用类方法、属性。而不是对象。

局部变量，既不属于类也不属于对象，所以永远不能用static修饰。

注：java方法中怎样传入多个参数？不知道有多少个。

    void f（int... Nums)
    {
    　　Nums[1]……；
    　　Nums[2]……；
    }//int后面加...,表明传入多个int。在方法中nums相当于一个数组引用。
参数个数可变的方法只能参数中可变的参数只能有一个。也就是说nums只能有这一个数组，而不能又有第二个多参数组。本质就是数组，实际上不怎么使用，不如直接传入一个数组引用。
　　
　　
`    Person p = new person();//注意：此中new才是创建对象，构造函数是对对象拥有的成员变量``进行初始化。二者功能是不同的。`

Java中this关键字
------------
this关键字用法：
this引用：在任何地方都可以使用this引用来调用非static方法。非static方法属于对象。
this调用：只能在构造函数第一行进行调用，用于调用本对象其他的构造函数。
在本类的方法中使用本对象的成员变量时，最好将this留下来。包括在构造函数中亦是如此。

this调用：使用this（）调用另外一个构造器。This()相当于一个构造器。
this引用：使用this.name;这是调用一个成员变量。

Java中递归
------------------

递归方法：
递归方法里面，实际上包含了一个隐式的循环。
递归方法就是再次调用自己，朝向已知的方向调用。

Java中重载
--------
方法的重载：
两同一不同：返回值相同，方法名相同。参数不同。
方法重载与返回值类型、是否static没有关系。
Java中访问权限
Private:当前类访问权限。
Protected:子类访问权限。
Public：公共访问权限。
没有设置访问权限：包访问权限。希望在同一个包中可以访问。
局部变量不能用这些修饰符修饰的原因：局部变量应该只在这个方法中有效，本来作用域就很想。所以就不需要使用修饰符限制使用范围了。

注：整个类是属于包的。也就是说类自己的修饰符可以省略。只能有一个类使用public修饰。就是主类。
如果这个类前加了public，那么在包内（package）和包外都可以访问。
如果用private等修饰，就没有意义了。
类名修饰符：public\final\abstract之一。

总之：
成员方法与变量的权限修饰符为：
Public：所有地方都可访问。
Private：本类内部可以访问，外部都不能访问。
Protected：本类内部和子类中可以访问，其他都不能访问。
未写：本包内可以访问，包外都不能访问。
所以，成员方法与变量的权限修饰符是public|protected|private|未写。

类的权限修饰符为：
Public：所有地方都可以使用这个类。
不能是Private：因为这个类不在其他类里面，所有设置为private之后，这个类就不能被使用了，因为private只能被本类内部使用。
不能是protected：因为这个类不在其他类里面，因为protected只能被子类所用，这个protected类不在另一个类中，所以他不能被另一个类的子类所使用。
未写：这个类可以被同一个包中的任何东西访问。
所以，类的权限修饰符只能是public或者未写。
Java中的包
包：命名空间的作用。将不同公司定义的同名类互相隔开。
所以，java中一个类的类名是：包名+类名。
定义包的语法：
Package 包1.包2.包3.……；

包名：用公司的域名的倒写。

要将一个类放在某一个包中需要：
在类的源代码中使用package指点放置目录路径。
生成的class文件必须放在package所声明的文件结构下面。可以手动建立package所声明的目录路径，然后将编译结果放进去。
还可以在编译的时候使用 javac -d . 源文件。这样-d选项可以自动创建package指明的目录路径，并将结果放在这个路径里面。也就是放在包里。

注意：在运行放在一个包中的class时，不再是java hi.  而应该加上包名：java hu.pi.hi。这样才行。
也就是说，运行包中的编译结果时，也必须将路径加上。而且当前目录必须在hu目录之外，不能进入包的路径中去运行class。必须在包的目录外运行（加上class的路径）。

总之，一旦为一个类加上了包名。那么这个类的名字就变为包名+类名。那么在任何时候使用这个类编译的class的时候，都必须使用包名+类名。如java命令运行这个class或者在其他源文件中import这个class的时候，均是如此。

使用这个类的时候，通过import包名来导入类。
还可以使用：import static java.lang.*;这就是JDK1.5后提供的静态导入。用于导入一个类中所有的static成员。

Java中的方法重写
--------------------
方法重写：重写后的方法：两同、一大、一小。
方法名、参数列表相同。
访问权限更大或者相等。
返回值类型更小或者相同。子类抛出的异常要更小。

在重写方法前面加上：@override，可以在编译的时候，让编译器强制检查重写的方法有无错误。没有别的用处。
super：用于调用父类的方法或者某一个构造器。
注意：方法会有重写，但是成员变量没有重写（即使子类有父类中同名的成员变量，也依旧不是进行覆盖，而是子类中有了两个同名的该成员变量），也就是说不能在子类中覆盖父类中国的某个成员变量，而是必须在构造器中进行初始化。
在子类中无法区分到底是使用子类还是父类中的同名成员变量、方法。默认的是访问子类中的，也就是说默认是加上了this。那么如果要使用父类的成员变量、方法，可以使用super关键字。
在使用this或者super作构造器调用的时候，都必须放在构造器的第一行。而且this与super调用构造器是不能同时出现的。
如果没有人为调用父类的super或者this构造器构造器，机器会自动调用父类的无参构造器。
否则会人工调用对应的构造器。


关于重写：
父类中的public方法可以被子类重写。
父类中的private方法不能被子类重写。因为根本就无法访问，更不必说重写了。
父类中protected方法能被子类重写。
父类中为表明访问权限的方法不能被处于不同包中的子类重写。
Eg：

     class newer
	{
	int a=10;
	private void f()
	{
		System.out.println(10);
	}

	}

    class newTest extends newer
    {
	private void f()
	{
		System.out.println(100);
	}  //这是newTest自己新建的方法，而不是重写了newer类中已有的方法。即使他们是同名的方法。
	public static void main(String[] args)
	{
		newTest n = new newTest();
		n.f();
	}
	}




Java中的多态
-------------
多态：可以使父类引用变量引用一个子类对象。使用的时候，依旧是使用父类引用变量来调用子类的方法。
所谓的态：行为、特征。
所谓的多态，就是同一个引用变量（如父类引用变量），在调用执行同一个方法的时候，表现出各种不同的行为特征。

多态实现的原因：
java中引用变量的类型有两种：
编译时类型：这就是写源代码时声明的引用变量类型。
运行时类型：决定于实际运行时这个引用变量所引用的对象。
如果，某引用变量的编译时类型与运行时类型不一致，就可能导致多态。
所以这样一来，两个编译是类型一样的引用变量，由于实际运行时类型不同，导致他们在调用相同的方法时，呈现不同的行为特征，这就是多态。
在编译的时候，编译器将父类引用变量视为父类变量。
在运行的时候，JVM将父类引用变量视为子类变量。

但是必须注意的是：多态针对的只是继承中那些在子类中已经重写的方法，而对于不是重写的方法，并不能体现多态的特性。也就是说，不能用父类引用变量来调用子类中新加入的方法。如果使用父类引用变量来调用子类中新加入的方法，就连编译都没办法通过。
因为：
在编译的时候，编译器将父类引用变量视为父类变量。
在运行的时候，JVM将父类引用变量视为子类变量。

Java中引用类型的强制类型转换
-----------------
向下造型：也就是强制类型转换：
那么怎样让父类引用变量能够调用子类新加入的方法呢？
当一个父类引用变量引用了一个子类对象的时候，这就是所谓的向上造型。是自动进行的。

那么怎样让这样的一个父类引用变量调用子类新加入的方法？
就要采用向下造型。强制将父类引用变量转换为子类引用变量，这样就可以通过新的子类引用变量来调用子类新加入的方法了。
使用向下造型的前提是父类引用变量是通过子类对象向上造型而得来的。

强制转换的原理：
是使得原来的父类引用变量的编译时类型发生改变，变成了子类的引用类型。
而父类引用变量的运行时类型无需发生改变，因为原来的运行时类型就是子类类型。


强制类型转换的注意点：
基本数据类型中，除了boolean类型，其他类型都可以使用强制类型转换来实现大空间向小空间的转换。
引用类型中，只能在具有继承关系的两个类型间进行转换（父类引用变量转换为子类引用变量）。否则在编译的时候即会报错。而且将父类引用变量转换为子类引用变量之前，必须保证这个父类引用变量确实是引用一个子类对象才可以进行下面的转换。

instanceof（）：用于判断前面的前面的引用变量是否引用后面类型的实例。
注意：使用这个函数时：要么前面的引用变量引用了后面类型的变量，要么二者有继承关系。否则编译时会报错。
Eg：
1

	Class A extends B；
	B b；
	b instanceof A；//false，二者具有继承关系。


Class A extends B；
B b；
b instanceof B；//true，b引用变量引用了后面的类型的实例。

	
Class A extends B；
B b；
b instanceof M；//会编译报错。因为b引用对象既不是M类实例，也与M类没有继承关系。

Java中常见异常
NullPointerException：空指针引用异常。
ArrayIndexOutOfBoundary：数组越界异常。
ClassCastException：类型转换异常：非引用子类对象的父类引用变量转换为子类引用变量发生异常。

Java中编译类型
------------------
一个误区：
在继承中，如果子类新加入了一个与父类同名的成员变量，不会覆盖父类的成员变量，而是子类拥有了两个同名的成员变量。那么在通过子类或者父类引用变量来调用该名字的成员变量的时候，具体是调用了哪一个成员变量，决定于这个引用变量的编译是类型（到底是子类引用变量还是父类引用变量）。
Eg：
Class A
{
 int a=10；
}

Class B extends A
{
 int a=20；
}//这样B类中有两个a成员变量，一个是10，一个是20.

那么，使用时，
B b=new B();
   b.a;//这里输出的是20这一个成员变量，因为这里引用变量的编译时类型是B。
A b=new B();//发生向上造型
   b.a;//这里输出的是10这一个成员变量，因为这里引用变量的编译是类型是A。
Java中的反射
反射：能够分析类能力的程序称为反射。对程序员没什么用处，只对工具设计者有用。

Java中的单例类
与单例类相联系的是一个设计模式：模板模式。
某些时候，我们只想为某个类创建一个对象。这时候就需要使用单例类。
要实现单例：
不能暴露构造器。否则可以自由创建多个实例。所以，需要人工写一个无参构造器，且设为private形式，这样可以防止JDK自己创建默认构造器。且构造器只能在类内使用。
设置一个静态field用于缓存在3中的方法所创建的实例，且这个field可用于检测保证仅创建了一个实例。
暴露一个方法，用该方法来返回一个实例。设为public。由于调用这个方法的时候没有实例，所以需要使用类来调用该方法。所以这个方法必须是static的。同时，该方法内部必须在创建一个实例之前先检测2中的field，保证只存在一个实例，这样才能保证这是一个单例类。
使用3中创建的方法来创建一个对象。
Eg：
public class singleTon
{
	public int a;
	private singleTon() //创建private构造器，防止JDK自己创建构造器
	{
	}

	private static singleTon h; //创建static field，用于缓存创建的单例对象，同时检测是否单例。

	public static singleTon f() //创建static方法，以创建单例对象，返回该对象引用。
	{
		if(h==null)
		{
			h=new singleTon();
		}
		return h;
    }
	public static void main(String[] args)
	{
		System.out.println(singleTon.f().a); //使用static单例对象创建方法来创建单例。
	}
	
	{
		a=10;
	}
	}



Java中的接口
----------------
接口的功能非常丰富，因为接口往往是和设计模式结合使用的。
接口的概念：
可以认为接口是一种彻底的抽象。
是从多个相似的类中抽取出来的一种规范。可以认为接口是一种规范。
接口体现的是通信的规范。例如电脑主板上的插槽，就是因为这些插槽都遵循统一的通信规范，所以也称之为接口。


接口的定义：

	[修饰符] interface 接口名
	{
	　　0-n个field；
	　　0-n个抽象方法；
	　　0-n个内部类、内部接口、内部枚举定义；
	}
接口实现的只是一个规范，表示某一种功能（仅是表示一个功能而已），而不代表一个实体，是一个比抽象类更抽象的东西，只表示一个功能，任何implement这个接口的类都具有了这个功能。

接口不能有构造器，也不能有初始化块。
interface修饰符：public|未写。因为类的修饰符就是public或者未写。见：Java中访问权限。Final修饰符也不行，因为interface中存在抽象方法。也没有abstract修饰符。Interface比abstract更加抽象。
接口名有形容词。接口代表它可以做某一件事情（具有某一项功能）。
接口里面field的修饰符：public static final三个。默认的就已加上了这三个修饰符。自己不能进行修改了，要么不写，要么写这三者中的一部分。即使自己写了别的也就只是在这三者基础上加。 所以，field必须在定义的时候就赋与初值。因为有final、static修饰，所以必须由程序员来赋初值，但是没有初始化块，而且static变量不能在构造器中初始化。
接口里的方法修饰符：默认修饰符：public abstract，不能用static进行修饰，因为abstract不能与static同时修饰。也不能有final修饰符。同样不能进行修改。限定死了。所以方法必须没有方法体。也就是是说接口是个更抽象的东西，里面的方法必须没有方法体。都是抽象方法。
接口里的内部类、内部接口、内部枚举，默认修饰符：public static。不能修改。


注：为什么借口的field、方法、内部类等这些都是采用public进行修饰？
Answer：因为借口的作用就是让别人使用这个功能，所以必须对外开放，所以都有默认public。
总之，接口内部和接口本身的修饰都可以不写，而使用自己默认的。写不写效果一样。

一个类只能有1个父类。但是一个接口可以有n个父接口。

对于一个java文件而言，里面只能有一个public类，运行的时候，会自动装载这个public类，然后装载这个public类中的static成员（包括static成员方法与变量），装载static void main方法的时候，就会自动从这个main方法开始执行。所以，java成员能够运行的道理，从要运行文件中的唯一一个public类开始，从这个public类的static main方法开始执行。

同样，对于，一个java文件而言，只能有一个public interface。其余都是默认的为空。可以将接口理解为一种特殊的类。是一种彻底抽象的类。

接口的使用
接口可用于定义引用变量，但是不能用于创建实例（接口定义的引用变量可以引用它的子类对象，这时就相当于向上造型，当然，进行向上造型后获得的接口定义引用变量，可以对其进行强制类型转换，变为实现类的类型，然后调用实现类中的所有成员方法）。接口里面不能有main方法子类的，也就是说，接口里面的任何方法都必须借助实现了接口的类的对象来调用，而不能通过接口调用，因为接口极其抽象，无实体。接口里的方法不能是static。

接口最大的用处就是供其他类来实现：implements。就是使得这个类具有接口所代表的功能。注：一个类可以同时实现n个接口。可以弥补java单继承的不足，相当于模拟了多继承。当实现类中实现了接口之后，就会获得接口中所有的抽象方法。由于接口中所有的方法都是抽象的，所以实现类中要么为所有的这些抽象方法提供实现，要么这个实现类继续做抽象类。

接口主要是在面向接口编程的时候有用。

注意：类实现接口时，由于接口中的方法默认的权限是public，而implements的要求被实现后的方法的权限比原来接口中的方法权限更大，所以，在类中实现接口中的方法的时候，该方法的权限必须加上public，否则就是空，空权限小于public，不符合implements的要求。

注：在方法的调用中，编译时类型由引用变量类型决定，运行时类型是由引用变量引用的对象决定。在调用一个方法的时候，首先要保证编译能通过，那么就要保证这个被调用的方法是引用变量类型的成员方法（即使是抽象方法亦可）。
然后到了运行的时候，再根据引用变量所引用的对象类型来决定该引用哪一个成员方法（是父类的方法还是子类重写的方法？）。
接口与抽象类之间的共同点与区别
二者都可以保护抽象方法。
都不能创建实例。
子类继承抽象类、实现接口时，都要求实现所有的抽象方法，否则子类也只能是抽象类。
接口里面只能有抽象方法（默认即是如此），抽象类里面可以没有抽象方法。
接口里面没有静态方法（因为是默认abstract的，所以不能有static的）。但抽象类里面可以有静态方法。
接口里的field都是public static final；但抽象类中是普通的。
接口无初始化块，抽象类中可以有。
接口中无构造器，抽象类中可以有。
接口可以n个父接口，抽象类只能有一个父类。


Java中的内部类、内部接口、枚举
----------------------
枚举：一种实例数固定的特定类。
Eg：
性别这个类，只有两个实例。
行星这个类，只有八个实例。
这些类，不同于一般的类，他们的实例数只有已知的那么几个。

内部类：把一个类在另一个类里面进行定义。
所谓的内部类，就是表面外部这个类具有内部类这个东西。内部类不是表示外部类的某个属性的。而是表示外部类本身所具有的具体的零件，是具体实体的一部分。
例如：
牛具有一项属性：名字，那么bull这个类具有一个属性name，那么程序语言的表示上就是：has a的关系，也就是说bull类有一个field是String字符串。这是表示某个类的属性的表示方法，作为一个field表示。
但是如果是牛具有某一个零件，如，牛具有角，那么这个角对于牛这个类来说就不能如牛的名字哪样表示成一个内部拥有的属性了。而是应表示成牛这个类的内部属性。


要注意：外部类不能用private修饰，也不能被protected修饰。因为在外部类本身之外并无外部类（这个外部类只是属于包）。所以这两个修饰符并无意义。也不能使用static修饰，不属于某个类。
但是，对于内部类而言，其处于外部类的里面，所以对于内部类而已，private、protected这些修饰符是有意义的，所以其修饰符可以是这个三种中任何一个。也可以使用static修饰。有static修饰的内部类属于外部类本身。否则是属于实例。

内部类上一级程序单元是外部类，外部类上一级程序单元是包。
Java中，每一个类是一个文件，然后很多类编译出来的结果放在一起组成一个包。

内部类的定义和普通类是一样的。内部类可以直接使用（需要加上外部类名.this<当外部类非static>或者外部类名.<当外部类是static>引用）外部类的属性、方法、构造器等，无论是private还是别的。
同样，外部类的方法也可以使用内部类，也就是在外部类的方法中创建内部类的实例。通过这个内部类对象引用变量来调用内部类自己的方法。
但是外部类不能直接使用内部类的成员（属性、方法等），而只能通过创建内部类对象来使用这个内部类的成员（属性、方法等）。不能直接使用。
实际上，将内部类视为寄生类，将外部类视为宿主类，更容易理解。

注：编译之后，内部类的文件编译而成的class文件名变为外部类$内部类.class。

调用原则：
内部类本质是寄生类。
没有static修饰的内部类，寄生在外部类的实例里面。
所以在外部类的方法中创建内部类的实例时，实际上是使用：new this.mouth(),
当然实际上在外部类方法中创建内部类的实例时，使用的是：new mouth()这样的写法。那么外部类的static方法等就不能访问static内部类。
有static修饰的内部类，是寄生在外部类的类里面。如果，内部类是static修饰的，那么，外部类的static成员方法就可以直接使用static内部类了，而且这个static内部类是属于整个外部类的，所以不用通过外部类实例调用外部类方法，不用在外部类的方法中来创建内部类实例。当然这个static的内部类也不能访问非static的外部类成员。

内部类的使用：
内部类优点：提供更好的封装性。将外部类的零件直接封装起来，可以让外部完全对其义务所值。
在外部类里面使用内部类和使用内部类是同样的，没有特殊。
在内部类外面使用内部类时，分为static内部类和非static内部类两种情况。
在外部类之外使用非static内部类时，使用外部类.内部类+变量名声明内部类的引用变量。
Eg：outer.inner in;//这就是创建了一个内部类引用变量。

创建内部类实例对象的时候，要先创建外部类对象，然后再创建内部类的实例。
Eg：
Outer ot；//先创建一个外部类引用变量。
Ot.new inner(); 	//使用这个外部类引用变量来创建一个内部类的实例对象。

如果某一个类是继承了内部类，那么该怎样使用内部类？
寄生类的子类也是寄生类。它也需要一个宿主。
>
	Class innerSub extends outer.inner
	{
	   //内部类的子类的构造函数就是与众不同的。因为子类必须要调用父类的构造函数一次，所以这个调用就是一个问题。
		Public Innersub()
		{
			New outer().super();//对于这个子类而言会自动调用父类的构造器，但是我们知道其父类的构造器必须通过父类的对象来调用，而不能直接调用，所以要先创建一个父类的对象。    
		}
		Public innersub(outer out)
		{
			Out.super();
		}//父类是一个非static内部类，所以子类自动调用父类的构造器的时候，需要使用父类的寄主对象来调用父类的构造器。所以这里可以传入一个out寄主对象。
	}


B、在外部类之外使用static内部类的时候。
他可以直接通过外部类来进行调用，而不用像非static内部类那样创建宿主类对象来使用内部类。只有用到外部类，内部类就有了，因为内部类就是属于外部类的，而不是属于外部类对象。不需要程序员去关注宿主，因为他的宿主是天然就有的。

子类继承Static内部类的时候，寄主天生就有，就是外部类本身。使用的时候，可以将外部类当成内部类的一个包即可。
>
	Class innerSub extends outer.inner
	{
	   //内部类的子类的构造函数就是与众不同的。因为子类必须要调用父类的构造函数一次，所以这个调用就是一个问题。
		Public Innersub()
		{
			New outer().super();//对于这个子类而言会自动调用父类的构造器，但是我   们知道其父类的构造器必须通过父类的对象来调用，而不能直接调用，所以要先创建一个父类的对象。    
		}
		//或者：
		Public innersub(outer out)
		{
			Out.super();
		}//父类是一个非static内部类，所以子类自动调用父类的构造器的时候，需要使用父类的寄主对象来调用父类的构造器。所以这里可以传入一个out寄主对象。
	}


局部内部类：用得不多。因为意义不大（因为局部内部类的作用域太有限了，仅在方法里面有效，也导致使用比较简单）。了解一些即可。
局部内部类的作用就是：当我们在任何一个方法中某个地方时，需要使用一个新的类的时候，如，实现一个接口或者继承一个类的时候，这个时候就要临时创建一个类，这时候不必再在外面创建类，太麻烦，可以在这个地方现场创建一个类，实现接口或者继承其他的类。这样就是局部内部类的作用。当然，内部匿名类也是这个作用。
>
	Public int f（）
	{	
		Class pro 
		{
			……
		}
		//或者
		Class pro implements per
		{
			……
		}
	}


局部内部类的内容和普通类都是一样的。

局部内部类可以同名的，如，在不同的方法中，可以定义相同的内部类。
所以，局部内部类的class文件名为（每一个类都有一个文件，当然包括，内部类、局部内部类这些）：外部类+n（表示是外部类中第几个局部内部类）+局部内部类.class。以代表多个重名的局部内部类。


匿名内部类：适合于创建只需要一次使用的类。没有名字的类。
所以，程序以后无法再次访问这个匿名内部类。
当程序在创建这个匿名内部类的时候，会立即创建这个匿名内部类的实例。

实际上在一个地方要使用一个新的类对象的时候，与其使用局部内部类，还不如使用匿名内部类，更加方便，且效果好。
语法格式：
>
	new 父类接口（）|父类构造器//这个新的匿名内部类可以是实现父类接口
					  //或者继承其他类，都可以，只是用一种随要随造					 //的方式予以实现，无名。但是方便。
	{
		//类体部分
	}

以上的语法格式返回了匿名内部类的实例对象。以后就只能使用这一个创建的实例对象。
>
	interface walkable
	{
    	void walk();
	}
	public class 
	{
		public static void main(String[] args)
		{
			walkable w=new walkable()
			{
			int a=10;//这里的匿名内部类的意思就是：walkable与{}共同					//构成对walkable这个接口的重载，然后加上new就					//创建了一个实现类的实例对象。再进行向上转型，					//被接口定义的变量所引用。
					//实际上单纯的接口是不能创建对象的。但是，如果					//匿名内部类实现了这个接口，就可以用这个匿名内
					//内部类创建实例对象了。
					//所以这里做了两件事：创建一个接口实现类、用这					//个接口实现类
			@Override
			public void walk()
			{
				System.out.println("walk");
			}
			public void f()
			{
				System.out.print("f");
			}
			//实现接口的匿名内部类中可以有field、重写方法、方法、			//初始化块，但不能有构造器，因为匿名内部类没有名字，
			//没办法写构造器。
			/*
			 * 以上代码相当于：
			 * class walker implenments walkable
			 * {
			 *		int a=10;
			 *		@override
			 *		public void walk()
			 *		{
			 *			system.out.println("walk");
			 *		}
			 *
			 *		public void f()
			 *		{
			 *			System.out.print("f");
			 *		}
			 *	}
			 *
			 *	walkable w=new walker();
			 * /
		}；//注意匿名内部类这里有一“；”
	}
	}


就是说，原来实现一个接口，然后用这个实现类来创建一个类对象的工作可以通过匿名内部类的方法予以完成，在任何地方，随要随做，无需名称，很快完成。



匿名内部类规则：
匿名内部类只能继承一个已有的类或者实现一个接口（而不能和普通的实现类那样实现多个接口）。
匿名内部类必须实现接口或者父类的所有抽象方法，因为，匿名内部类不能是抽象的。因为创建这个匿名内部类之后就需要立刻创建实例。
匿名内部类没有构造器，因为没有类名，但是可以有初始化块。


枚举
用于代表实例数量是固定的特殊类。有点像单例类，只不过有多个实例。枚举非常重要。
语法：
>
	[修饰符] enum 枚举名
	{
		//必须在第一行立即写上该枚举的所有实例对象名。这里写上实例，表面上看是写出对象名，实际上是在调用构造器进行初始化。所以，如果本枚举类拥有无参构造器，那么直接写对象名就是调用默认构造器。但是，如果没有无参构造器，就需要使用有参构造器，就不仅仅是直接写对象名就行，还得显式调用有参构造器。
　　　
		//其他部分和普通类是同样的。同样可以有方法、field、构造器（必须是private构造器，默认的是private的。大部分时候不用写）、内部类等东西。其本质就是一个类。
	}

>
	Public enum gender
	{	
    	 Male,//这是调用了该类的默认构造器，省略了括号。Female（“woman”）；//显式调用有参构造器。
		//实际上相当于：gender female=new gender（“woman”）；
		String name；
		Gender（）
		{name=“man”；}//默认构造器
		Gender（String agender）
		{name=agender；}//有参构造器
	}

enum关键字的地位与class这个关键字的地位是一样的。
修饰符：public|省略 或者 abstract|final（但是二者必须出现其中之一。默认的是final）
枚举类的特征：
默认继承了java自己的enum类，实际上还继承了object类。由于enum都继承自一个java中的enum，就和普通类都继承自object类一样，都继承了某一些方法。例如：所有的enum都有values（）方法，这个方法可以返回所有的枚举值。
枚举类的构造器只能用private来修饰，因为不能再类外随意创建实例，实例数已经固定了。保护构造器。
使用枚举类的时候，直接用即可，不能再去new创建。
枚举类的方法要非常小心。这里的主要问题是：
由于枚举是特别的类，因为他的类对象在设计类的时候就已经设定了，而且相应类对象的各个属性也已经设定了。所以就不能在类中方法里面随意设定属性的值。也就是说，在set（）这种方法里面。设置某些属性的值的时候，在这些方法中一定要进行所要设定目标值的合理性的检验，否则就会导致违背类自己限定的对象的实际情况。或者直接不许出现设定对象属性的方法。
包含抽象方法的枚举类。
如果某个方法有abstract修饰，那么就不能有final和static。
更重要的是，当枚举类具有抽象方法的时候，那么这个枚举类就是一个抽象类，那么，这个抽象内部类怎么能够有实例对象呢？
注：对于一个抽象类而言，不能通过调用他的构造器来创造他的对象，这个时候，如果真需要使用抽象类的对象，都可以通过匿名内部类来进行。
>
	abstract class mt
	{
		int f=10;
		public abstract void fo();
		public void fm()
		{
			System.out.println("abs");
		}
	}	
>
	public class abs 
	{
		public static void main(String[] args)
		{
			System.out.println("hello world");
			mt m=new mt()//这里通过一个匿名内部类来创建一个抽象类的对象。
			{
				public void fo()
				{
					System.out.println("fo");
				}
			};
			m.fm();
		}
	}

Answer：这时候可以使用匿名内部类，使用匿名内部类来创建包含抽象方法的枚举类的对象。这个匿名内部类继承的就是这个包含抽象方法的枚举类（需要实现枚举类中的abstract方法）。因为要创建这个枚举类的对象，所以就可以先创建继承本枚举类的子类，然后通过这个子类创建枚举类的对象。然后就可以随意使用我们创建的这些对象了。
>
	public enum seasons
	{
	spring()//这里就是一个匿名内部类，继承了枚举类。然后通过这个匿名内部类创建了一个对象。因为不能通过调用枚举类的构造器来初始化创建枚举类的对象，所以只能使用匿名内部类。这样可以避免抽象枚举类无法通过构造器构建对象的缺陷。
	{
		public void infor()
		{
			System.out.println("spring");
		}
	},
>
	summer()
	{
		public void infor()
		{
			System.out.println("summer");
		}
	},
>	
	autumn()
	{
		public void infor()
		{
			System.out.println("autumn");
		}
	},
>
	winter()
	{
		public void infor()
		{
			System.out.println("winter");
		}
	};
>	
	public abstract void infor();
>	
	public static void main(String[] args)
	{
		System.out.println("hello world");
>
		seasons.spring.infor();
		seasons.summer.infor();
		seasons.autumn.infor();
		seasons.winter.infor();
	}
	}

枚举是一个特殊类：实例数固定，且必须在类第一行就写出来。

枚举类也可以实现接口。
A、我们可以在枚举类里面实现接口中所有的抽象方法。
这样可以保证枚举类不是abstract类，可以创建实例，然后其他的和一般的枚举类都是一样的。
B、我们不在枚举中实现接口中的所有的抽象方法。
这样枚举类就是abstract类，然后就可以使用匿名内部类创建枚举类的对象。

注，选择语句switch的表达式必须是以下几种之一。
>
	switch（byte|short|char|int|String|枚举）；只有这六种，如double等都是不行的。

Java中的jar命令
---------------
作用：把多个文件打包成一个压缩包。与winzip压缩格式是一样的，只不过jar压缩结果中在各种class文件之外会添加一个meta-inf的文件夹，其中有一个menifest.mf文件，这个文件就是清单文件。
通常得到的压缩包有3种:
*.jar:它里面包括的是n个class文件。
*.war:它是一个web应用打包生成的文件。与jar的格式是一样的，只是后缀不同而已。
*.ear:它是一个企业应用打包生成的包。

Jar命令的用法：
某个工程在一个文件夹中，里面都是class文件。将所有的class文件压缩成一个jar文件压缩包。
jar -cvf myname.jar *.class   //f:表示后面的是目标jar文件名。*.class表示将文件夹中所有的class文件都压缩起来。

如果不生成清单文件：
>
>
	jar -cMf myname.jar *.class

查看jar压缩包的内容：
>
	jar -tf myname.jar
	jar -tvf myname.jar:查看详细内容

解压：
>
	jar -xf myname.jar:将jar压缩包解压。

更新压缩包：将新class添加到原来的jar包中。
>
	jar -uvf myname.jar *.class //将文件夹中的新的class加入到原来的jar包中。


为什么做jar包？
因为一个真实项目中会有很多class文件，所以存在系统管理不方便、性能低（jvm需要依次加载不同的class文件，效率很低）。
所以可以将多个class文件打包成一个jar包，这样的好处就是：多个class文件统一成一个jar包方便管理，jvm不用将jar包解压再加载，而是可以加载整个jar包（加载所有的class），这样效率高。


将整个项目打包成可执行的jar包：
我们讲所有的class打包成jar文件后，这些class中只有一个class中的main方法才可以知道执行，也就是说项目是从这个class文件开始执行的，但是jvm不知道哪一个才是开始执行的class文件，所以，需要打包成可执行的jar包。
通过-e选项告诉jvm哪一个class才是整个项目的主类。
>
	jar -cvfe myname.jar hello *.class//后面的说明hello.class是主类，*.class表示压缩文件的来源class。
产生的文件在已经装了JVM的情况下可以点击运行。
如果没有安装JVM，可以使用：
>
	java -jar my.jar来进行运行。//用于运行控制台程序。
	javaw -jar my.jar//这是用于运行界面程序。


Java中的入口方法
------------------------
系统JVM在调用这个main方法的时候，JVM与我们的类不会在同一个包中，JVM也不会是我们这个类的子类。所以只能用public修饰main方法。
也不能先创建实例来调用main方法，只能用类拥有的方法，这样在JVM载入这个类的时候，就自动加载这个类所拥有的方法。所以main方法就是一个static方法。
Main方法的参数：args，这是一个String数组，默认长度是0；可以在运行的时候，接参数，将参数值传递进入main方法。
Java 主类名 参数1 参数2 参数3……


Java中与系统有关的两个类
-------------

1、System类
代表我们的JVM所在的操作系统，如XP系统。
如果要获取操作平台的相关特性，就要使用System类
System中所有的方法和field都是static的。无需对象来调用。

System.out:代表屏幕这个对象，这个out实际上是System这个类的一个static field，属于整个类。因为系统本来就有这个东西嘛，而且是类拥有的。

System.in:代表键盘这个对象，这个in实际上是System这个类的一个static field，属于整个类。

System.exit(int status):使用这个static方法可以退出JVM，这个方法实际上是System这个类的一个static方法。遇到这个代码，该java程序立刻结束退出虚拟机。

System.getenv()//获取所有环境变量

System.getenv(String name)//获取指定环境变量值

System.getProperties()//获取所有的系统属性

System.getProperty(String key)//获取指定的系统属性

Runtime类
代表JVM所在的JRE
JRE=JVM+核心类库（JDK）
若要获取JVM（虚拟机）的特性，就要使用Runtime类。

Runtime类的方法不是static的，而且这个类没有构造器。
但是这是一个单例类。它的构造器被隐藏了，外界是看不到的。
只能通过getRuntime()这个static方法来获得实例。
然后通过这个实例来调用runtime的各种方法进行操作
>
	Runtime rt=Runtime.getRuntime();//获得runtime类的实例
	System.out.println(rt.availableProcessors());//使用这个实例调用这个类的方法，获得JVM的处理器个数

还可以通过Runtime类对象的方法exex（）来调用运行操作系统（xp）命令或者其中的一个程序：
实际上只要是安装于这个系统中的所有软件都可以通过这个类对象进行调用运行。
>
	rt.exec("D:/Program Files/Bin/QQ.exe");//在虚拟机中开辟一个新的进程，然后再执行调用系统中的某一个程序。
	注意调用时的路径问题，如果没有指定绝对路径，而只有相对路径，就回到path环境变量中进行搜索。


因此，有了这个东西，我们可以做一个有界面的程序，界面上都是本系统中拥有的所有程序的图标按钮，然后每一个按钮都和对应的程序.exe连接在一起，那么运行了这个程序之后，点击相应的按钮就可以快捷启动对应的软件。

java中用于处理日期的类
----------
Date类，表示一个日期，
未过时的构造器只有：
Date()与Date(long date),
当然，过时的方法等都还是可以使用。
在java中月份从0开始。
Date是毫秒数，从1970开始。System类中有一个static方法currentTimeMillis()用于获取当前时间已经过的毫秒数。
>
	//initialize the de with default empty constructor_
	Date de=new Date();
	System.out.println(de);
>		
	//get the currentTimeMillis from 1970
	System.out.println(System.currentTimeMillis());
>
	//initialize the de with default empty constructor_
	de=new Date(System.currentTimeMillis()-3*24*60*60*1000);
	System.out.println(de);//output the date three days earlier

calender类，也表示一个时间。
由于date类已经过时了，所以要使用calender类来代替。但是date类并不能完全丢弃。
但是calender的构造器不能被调用。所以不能自己调用该类的构造器去创建对象实例。
而是通过其一个static方法去创建一个实例。这个方法是getInstance();
>
	//output the static field of clendar
	System.out.println(Calendar.DAY_OF_MONTH);
>	
	//get the object of calendar class
	Calendar cal=Calendar.getInstance();
	System.out.println(cal.getTime());
>		
	//set the time field
	cal.set(Calendar.MONTH,10);
	System.out.println(cal.getTime());
>
	//add the value to the field without the limits
	cal.add(Calendar.MONTH,12);
	System.out.println(cal.getTime());
>						
	//add the value to the field with the limits
	cal.roll(Calendar.MONTH,12);
	System.out.println(cal.getTime());


Java中的正则表达式
---------
所谓的正则表达式就是：可以匹配n个字符串的字符串模板。是一个非常强大的字符串模板。
*代表n个字符
？代表一个字符
一般在命令行中，经常使用此类的符号来搜索。但是功能太弱。
所以需要正则表达式。是跨语言工具。

注：vim编辑器对正则表达式支持很好。
“/”+正则表达式

A、正则表达式支持的通配符有：
>
	“.” :匹配一个任意字符。
	“\s”:space,匹配一个任意的空白、tab。
	“\S”:space,匹配一个任意的非空白、tab。
	“\d”:匹配任意一个数字。Digital。
	“\D”:匹配任意一个非数字。
	“\w”:匹配一个单词字符。
	“\W”:匹配一个非单词字符。

注：实际写程序中，由于需要转义，所以在代码中，”\”应该写为“\\”。

Java中的正则表达式也不是足够强大。
Java中正则表达式：regular expression：regex包。
有两个正则表达式的工具类：
Pattern类与Matcher类。

注意：正则表达式本身就是一个String对象。

String类中与正则表达式有关的几个方法：

Match（String regex）：用于判断String对象是否匹配后面的regex模板。
>
	String str="1a3s";
	System.out.println(str.matches("\\d\\w\\d\\S"));//匹配。编程的时候使用转义字符，\\表示\。

replaceAll（char a, char b):替换
>
	System.out.println(str.replaceAll("a","b"));
	Split(String regex);//按照通配符的位置所在进行切开。

B、正则表达式中的方括号表达式：
枚举：[ab中]：表示“a”“b”“中”三个字符中的任意一个字符。

范围：[a-f]：表示a-f这个范围内的任意一个字符。

枚举与范围共存：[a-f123]:表示a-f这个范围、1、2、3这些字符中任意一个字符。

求否：[^a-f]：表示不是a-f这个范围内的任意一个字符。
      或者，[^abc]:表示不是a、b、c中任意一个字符。

求交：[a-g&&[^b-c]]:表示a-g范围与非b-c范围的交集中的任意一个字符。

()：表示括号里面任意一个字符串：（sd|fg|er）：表示这个三个字符串中任意一种。

C、正则表达式中的特殊字符：
>
	()、[]、{}、\、？、*、+、^、$
对于这些特殊字符，如果在正则表达式中出现，就要对他们使用转义字符。
>
	^表示一行的开头
	$表示一行的结尾

D、正则表达式中表示出现次数的副词：作用是用于修饰出现在其前面的通配符。
>
	？：表示？前面的东西可以出现0-1次。
	* ：表示*前面的东西可以出现n次。
>
	\d?:出现一个数字
	\w*:出现n个字母
	.*:出现n个字符
>
	+：表示+前面的东西可以出现1-n次。
	{m，n}：表示前面的东西可以出现m-n次
	{，n}：最多n次
	{m，}：最少m次
	{x}：表示出现x次

注：正则表达式中，直接写数字，表示没有使用通配符。


Pattern类的使用。
Pattern类对象实际上就是代表了一个正则表达式模板。它们就是同一个东西。
没有构造方法，需要通过一个static方法创建一个pattern类对象。
>
	Pattern pa=Pattern.compile(“\\w”);//创建了一个pattern类对象。


Matcher类：表示一个匹配工具类。
有用的matcher方法
>
	Find（）；
	Group（）类；

如果想正则表达式具有更复杂的功能，那就需要用到这两个类。其他时候不必使用，一般的匹配符即可完成。

例如：实现特定字符串搜索提取的功能：使用这两个类。
如，创建一个网络爬虫，其功能就是：从任何一个网站开始，通过提取出这个网站上的所有超链接，获得其他网站的入口，这就是网络爬虫的作用。
爬虫工作步骤：
向指定网页发送请求（申请访问网页）。
获取该网页的响应内容（就是网站将网页的内容发送过来）。
提取出网页内容中的超链接地址。----使用正则表达式，使用这两个类的作用。
向提取的链接网页发送请求，递归这几个步骤。




Java中的国际化
--------------
所谓的java的国际化，就是希望程序本身自适应所有的用户（各种语言界面）环境。就是I18N。

其本质就是：查找、替换。
就是对程序中出现的字符或者字符串到资源文件中进行查找替换成目标的字符或者字符串。


资源文件：用于为程序提供国际化消息。
资源文件的命名：<baseName>_语言代码_国家代码.properties
>
Ms_zh_CN.properties

同一个程序的所有资源文件的baseName必须是相同的，也就是说对于不同语言的资源文件命名，baseName都是一样的。
该文件中内容：
>
	hi=你好！

如果资源文件中包含有非西欧字符（中文，日文等），就需要使用native2ascii工具类来处理这个文件，然后才能用。
使用这个工具处理资源文件的命令：
>
	native2ascii Ms_zh_CN.properties mse_zh_CN.properties //将前者处理成后者这个文件。就是将汉字处理成标准的Unicode值。


使用ResourceBundle类来加载资源文件。
>
	Locale currentLocale=Locale.getDefault(Locale.Category.FORMAT);//获得当前locale。也就是我的这台计算机所在的区域和使用的语言，以备在下一步中选用所对应的语言资源文件。
>
	ResourceBundle res=ResourceBundle.getBundle(“mse”,currentLocale)；//使用ResourceBundle来加载资源文件。
	System.out.println(res.getString(“hi”));//使用查找替换，将”hi”替换成”你好!”也即是使用资源文件。



国际化中，还有一个问题就是占位符，就是这个字符串暂时未定，只能在语言资源文件中写上一个占位符。

资源文件中：
>
	hi={0}，你好！{1}  //在资源文件中加上占位符，以供运行时参数来填补占位符。
	源程序中：
	System.out.println(MessageFormat.format(res.getString("hello"),args[0],args[1]));//这里使用MessageFormat类，为消息中的占位符填充参数值。

运行这个程序的时候，使用运行时参数args[0],args[1]来填充资源文件中的占位符。

CMD中：
>
	java hell 张三 李四 // 这里在运行的时候，用张三、李四两个字符填充语言资源文件中两个占位符。


国际化的步骤：
提供资源文件。
对于非西欧字符，要将它进行处理成标准Unicode字符。使用native2ascii工具。
探查获得本计算机所在区域以及所使用的语言。
使用一个ResourceBundle类来绑定我们所需要的语言资源文件，也就是将探测到的计算机所使用的语言与我们已有的语言资源文件链接起来。。
在程序中通过查找替换的形式使用语言资源文件中所对应的语言。


那么怎样查询所需语言和国家代码？
使用Local工具类即可。
>
	Locale currentLocale=Locale.getDefault(Locale.Category.DISPLAY);


Java中的Format类的使用。
Format类有三个子类，MessageFormat、NumberFormat、DateFormat。
NumberFormat：用于格式化数字，所谓格式化数字：就是将数字转换成相应所要求格式的字符串。
不能使用构造器来进行构造，而是使用static方法来获得实例对象。
>
	getCurrencyInstance（）；用于将数字格式化成货币字符串。
	getIntegerInstance（）：用于将数字格式化成整数字符串。
	getPercentInstance（）：用于将数字格式化成百分号字符串。

并且，这些方法中还可以传入locale对象，设置格式化成哪个国家的字符串。

得到实例之后，调用以下方法，就可以将数字转换成相应所要的字符串。
>
	String format（double number）；
>
	DateFormat：用于格式化日期。
	不能直接创建实例，而是通过static方法创建实例。
	getDateInstance（）；用于将日期对象格式化成日期字符串，只有日期，没有时间。
	getTimeInstance（）；用于将日期对象格式化成时间字符串，只有时间，没有日期。
	getDateTimeInstance（）；用于将日期对象格式化成日期时间字符串，都有。

并且，这些方法中还可以传入locale对象，设置格式化成哪个国家的字符串以及格式化风格。
>
	DateFormat  usShort=DateFormat.getDateTimeInstance(DateFormat.SHORT,DateFormat.LONG,Locale.US);

得到实例之后，调用以下方法，就可以将日期对象格式化成相应想要的字符串。
>
	Date date = new Date();//创建一个时间对象实例。
	System.out.println(df.format(date));


还有一个常用的simpledateformat是dateformat的子类。
其可以进行任意自定义格式的格式化。简单的日期时间格式器。
可以将日期格式化为字符串，也可以将字符串格式化为日期。
其具有构造器。

1、按照自己的要求将日期对象格式化成一个日期字符串。
>
	SimpleDateFormat sdf = new SimpleDateFormat("生日：y年M月d日,是今年的第D天");//将格式器设定为我们所需要的任何格式。
	System.out.println(sdf.format(date));//使用格式化器。

它的格式化是随心所欲的。

将一个日期字符串格式化成一个日期对象。
>
	String dat = "2014/5%25 13.34/12";//时间字符串
	SimpleDateFormat sdf1 = new SimpleDateFormat("y/M%d H.m/s");//创建对象
	Date da = sdf1.parse(dat);//将时间字符串转换成时间对象
>		
	System.out.println(da);//输出时间对象。





Java中的容器类
---------
Java中的容器用于装对象。
那么这些容器中应该有哪些方法？
装入对象的方法。
把对象读取出来的方法。读取之后，这个对象依旧在容器当中。
把指定对象从容器中删除。
把整个容器清空。
遍历，将每一个对象都读取一次。
将A容器中的对象倒入到B容器。
从A容器中的所有对象中减去B容器中的所有对象。
容器之间求交集。

容器类的所有方法都是通过实现别的方法接口来达到目的。

这些定义了各种方法名的接口有：
Collection接口。里面都是各种方法的声明的集合，没有定义方法，因为接口是极其抽象的，里面都只有抽象方法。
Set接口，其继承自collection接口，内容基本上和collection一样。使用条件：存放位置无索引，但不是随机的，不允许存放元素重复。（被集合实现）
List接口，其也继承自collection接口。使用条件：存放位置有索引，因此元素可以重复。类似于数组。（被线性表实现（顺序表或者链表））
Queue接口，继承自collection接口。使用条件：先进先出。（被队列实现）

实现了以上那些接口的类有：
HashSet：实现了Set接口的类。HashSet无序。其有一个子类，LinkedHashSet，这是有序的。
   
　　另，对于Set接口而言，其还有一个子接口SortedSet，这个接口可用于需要排序的集合（也就是说，一旦一个类实现了这个SortedSet，那就具有了排序的功能，这个接口里面的功能就都有了）。
　　TreeSet类实现了SortedSet这个接口。
　　
List是被线性表实现，线性表可以基于顺序表或者链表。
所以，实现List接口的有ArrayList类（基于顺序表的实现）、LinkedList类（基于链表的实现）、Vector类（仅作了解，几乎无用了）。

Vector类有一个子类Stack（仅作了解）。

Queue，被队列实现，队列是特殊的线性表，也就是在继承线性表类之后加入某些特征（只能先入先出）（进行功能上的削弱）获得队列。
Queue派生了一个子接口Deque，这个子接口的使用条件：双端队列，两端都可进可出。也就是可以先进先出，也可以后进先出。其本质就是：即是栈也是队列。既有栈的方法也有队列的方法。在java中看上去是没有栈这个东西，但实际上是有的，就是Deque这个东西。
Deque接口的实现类：
基于顺序表的实现，ArrayDeque类。
基于链表的实现，LinkedList类，这个类既实现了Deque又实现了List，功能强大。



以上这些实现类中，HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque这5个类要重点掌握。


Java中的容器类的使用。
1、要使用接口作变量，而不是使用类做变量。
>
	Collection<String> c1 = new HashSet<>();
这里使用了接口collection做变量，而没有使用类HashSet作变量。同时，这里的collection使用泛型规定了容器中对象类型，那么后面的类HashSet就可以不必写出对象类型，这就是所谓的“菱形语法”。

`Removeall()`与`addall()`是针对容器与容器之间的操作。
`Retainall()`是容器之间求交集的操作。
遍历Set集合
使用迭代器：
>
	Iterator it = c1.iterator();//创建迭代器
	while(it.hasNext())
	{
		System.out.println(it.next());//使用迭代器
	}

使用foreach循环：
>
	for（String elem：c1）
	{
	}

Java中的HashSet
--------------------
HashSet的存储机制：其底层是一个数组。
HashSet的构造器：HashSet(int initialCapacity, float loadFactor)
这里的参数分别是：
数组的长度，但是不一定是实际数组的长度，因为这里的数组的长度永远是2的n次方，这样数组实际的长度是最接近与2的n次方的。
HashSet<String> ha = new HashSet<>(3);//底层数组长度自动扩展到4。

实际上HashSet的工作原理是：当感觉底层数组的空间不足的时候，就会自动创建一个长度扩充一倍的底层数组，将原数组中的东西复制倒入，原数组变为垃圾等待回收。这个过程叫重hash。

负载因子：
那么怎样的时候才叫感觉空间不足？就是当已使用的空间占总空间比例达到负载因子的时候。负载因子是一个小数。默认0.75，底层数组长度默认16；


HashSet存入元素的机制：
当有对象元素要存入的时候，会调用这个对象元素的HashCode（）方法，获得一个int值。
根据返回的int值，计算出这个对象元素在底层数组中的存储位置（也就是数组中的索引）。Hash值一样则存储位置一样。
如果要放入的位置是空的，那么直接放入即可。
如果该位置上已经有了元素，就会在此位置上形成链表，同一个位置上的元素形成链表。

HashSet取出元素的机制：
当要从HashSet中取出一个对象元素的时候，会调用这个对象元素的HashCode（）方法，获得一个int值。
根据返回的int值，即使出这个对象元素在底层数组中的存储位置。
如果该位置恰好是要找的元素，直接取出来即可。
如果这个位置是一个链表，就需要挨个遍历这个链表，知道找到我们要的元素对象。无链表的时候，效率最高。最理想的情况下，HashSet的性能可以接近于数组。
这里可以知道，当负载参数过大的时候，会导致HashSet被装得过满，这样导致数组元素位置相重，进而导致链表的出现。降低HashSet的性能。
注：当我们要将一个对象元素存入到Hash表中的时候（HashSet/HashMap），需要在这个类的对象中重写HashCode（）方法，因为存入或者取出这个对象元素的时候，都要使用它的HashCode（）方法。
>
    //the use of hashcode() in the HashSet
    //the override of equals()
    import java.util.*;
    class A
    {
	    private int count;
    	public A(int acount)
	    {
		    this.count=acount;
	    }
    	//类的判等equals()重写。
	    public boolean equals(Object obj)
	    {
		    if(this==obj)
		    {
			    return true;
		    }
		    if(obj!=null&&obj.getClass()==A.class)
		    {
			    A targetobj=(A)obj;
			    if(this.count==targetobj.count)
			    {
				    return true;
			    }
		    }
		    return false;
    	}
	    public int f()
    	{
    		return this.count;
    	}
    	public int hashCode()
    	{
    		return 20;
    	}
    }
    public class hashSetTest2
    {
	    public static void main(String[] args)
	    {
	    	HashSet<A> ha = new HashSet<>();
	    	ha.add(new A(1));
	    	ha.add(new A(1));
	    	ha.add(new A(1));
    		System.out.println(ha);
	    	for(A a:ha)
	    	{
	    		System.out.println(a.f());
    		}
    	}
    }


hashSet怎样才认为两个对象是相等的？这样这两个对象才会放在底层数组中相同的位置。 
> 
1. 这两个对象的hashCode（）返回值相等。  
2. 两个对象通过equals（）方法判等返回true。  

这样就要求我们类的自定义方法`hashCode()`与`equals()`是一致的。这里的一致，指的是必须在这两个方法中要考虑相同多的类属性。如，在`equals()`方法中要保证`name`与`num`属性都相等才行，那么在`hashCode()`方法中也必须使用这两个属性来参数`hash`值，从而保证返回的`hash`值能够代表这个两个属性。俱缺一不可。

这两个方法相对于上面的必须改写为：
>
    public boolean equals(Object obj)
	{
		if(this==obj)
		{
			return true;
		}
		if(obj!=null&&obj.getClass()==A.class)
		{
			A targetobj=(A)obj;
			if(this.count==targetobj.count&&this.name.equals(targetobj.name))
        	{
    	        return true;
    	    }
    	}
    		return false;
    }
    public int hashCode()
    {
    	return this.name.hashCode()+this.count;
    }


HashSet的子类LinkedHashSet。  
其存储机制与HashSet类似，但是，HashSet的底层机制是一个数组，而且数据存放位置是一个无顺序的，也就是与放入时顺序无关的，这样，遍历整个Hashset的时候就是无序的。  

而LinkedHashSet的底层机制是一个链表，这样，在链表中顺序就和放入对象的顺序是一致的，这样在遍历linkedHashSet的时候，就是有序的，与放入顺序一样。


Java中的TreeSet
-----------------
特征：保证Set中的元素对象都是已经排好序的。  
对于字符串，按首字母的ASCII码排序。  
TreeSet是标准的“红黑树”；  
树——>二叉树——>排序二叉树——>平衡排序二叉树——>红黑树。

TreeSet的底层用一棵红黑树。红黑树的存入、检索性能很好。  
在没有出现大量的“链表（位置重合、重hash）”的情况下，HashSet的性能比TreeSet的好。

TreeSet相对于HashSet的优点： 
> 
1. HashSet中有一定量的空间是空的（内存的浪费），而TreeSet的空间利用率要高。  
2. TreeSet可以保证集合元素是有序的。

由于TreeSet中元素是有序的，所以要求放入到TreeSet中的元素对象是可以比较大小的。

TreeSet在比较中认为两个元素对象相等的标准：  
只要这两个元素对象通过`compareTo()`方法返回值是0，那么TreeSet就认为二对象相等。而与`equals()`方法无关（只与`compareTo()`方法有个）。所以我们要重写放入TreeSet中的元素对象的所属类中`compareTo()`方法。

java容器中比较元素对象大小的两种方式：  
>
1. 自然排序：也就是让我们自己写的类实现Comparable接口。主要就是重写里面的compareTo这个方法。这个方法被自动用于元素大小比较和排序。
元素实现了这个接口之后，元素自身就是可以进行排序的。  
2. 定制排序：在创建TreeSet的时候，提供一个comparator对象，该对象可负责对元素进行比较大小。这里集合中元素对象无需实现comparable接口（本身无排序功能）。这里的TreeSet就需要在构造的时候传入一个comparator对象，实际上传入的是一个comparator匿名内部实现类。这个匿名类产生对象用于进行比较。



Java中的List接口
-----
List接口就是用于线性结构类的 。  
其特征就是：可以依据元素的index来存、取元素对象。    
List接口中有大量的依据`index`来进行操作的方法。  所谓的依据index进行操作就是：在操作的时候告诉你的是元素的index，就是编号。即使是链表，告诉你的也是index编号，这就是所谓的一句index进行操作。链表和顺序表都是告诉你元素编号的。

同样，这里的List接口一般都用来创建引用变量，引用它的子类实例，以此体现多态。  
但是要注意的一点就是，如果使用接口创建的引用变量来引用子类实例，那么在要使用子类才有的方法之前，必须要先进行强制类型转换为子类实例变量。  

由于可以依据`index`访问元素，所以其多了一种遍历方式：
>
	List<String> ls = new ArrayList<>();
	for(int i=0;i<ls.size();i++)
	{
		System.out.println(ls.get(i));
	}

1. ArrayList实现类  
这个类实现了List接口，底层是一个数组。  
2. Vector实现类  
这个类和ArrayList相似，底层都是一个数组。这二者的性能非常快，比`hashSet`还快。  但只是在查找的时候快，在删除、插入的时候很慢。  
ArrayList与 Vector的区别:  
Vector从JDK被ArrayList代替，所以，能不用Vector就不用。Vector是线程安全的（但是实现很糟糕），ArrayList是线程不安全的。ArrayList的性能更好。即使在多线程情况下也不要使用Vector，而是通过Collections工具类来将ArrayList转换包装为线程安全的。    
3.  LinkedList实现类  
特征：即是线性表、又是队列、还是栈。  
其底层是基于链表实现的。**通常**认为性能比不上ArrayList。在存取的时候性能很好，在查找的时候很慢。因为它也是根据索引进行操作的，也就是说，在操作的时候告诉LinkedList的依旧是index。

Java中的Queue接口
---------
queue接口唯一的继承接口是Deque。  
功能既是队列（queue）又是栈（stack）。两端都可出可入。实际上就是功能受限制的线性表。实际上就是继承线性表而来的。

Deque作栈使用：
>
	import java.util.*;
	public class dequeStackTest
	{
		public static void main(String[] args)
		{
			Deque<String> de = new ArrayDeque<>();
>
			//push the elems into the ArrayDeque
			de.push("hi");
			de.push("hello");
			de.push("world");
			de.push("that");
			de.push("is");
>
			//pop the elems out of the ArrayDeque
			System.out.println(de.pop());
			System.out.println(de.pop());
			System.out.println(de.pop());
			System.out.println(de.pop());
			System.out.println(de.pop());
>	
			//push the elems
			de.push("hi");
			de.push("hello");
			de.push("world");
			de.push("that");
			de.push("is");
>		
			//peek the elems of the ArrayDeque, peek but not remove
			System.out.println(de.peek());
			de.pop();
			System.out.println(de.peek());
			de.pop();
			System.out.println(de.peek());
			de.pop();
			System.out.println(de.peek());
			de.pop();
			System.out.println(de.peek());
			de.pop();
		}
	}

Deque作队列使用：
>
	import java.util.*;
	public class dequeQueueTest
	{
		public static void main(String[] args)
		{
			Deque<String> de = new ArrayDeque<>(); 
>			
			//insert at the end of the arraydeque.
			de.offer("hello");
			de.offer("world");
			de.offer("good");
>
			//poll the elem 
			System.out.println(de.poll());
>
			//peek the elem
			System.out.println(de.peek());
		}
	}


Deque具有两个子类：  
1. 基于数组的实现，ArrayQueue  
2. 基于链表的实现，LinkedList

Deque只是一个接口，所有的方法都是依靠实现类：ArrayQueue与LinkedList实现。


Java中的操作集合的工具类
---------------
工具类：  
Arrays类：操作数组。  
Objects类：操作对象。
Collections类：操作集合。

Collections所有方法都是static方法。
>
	import java.util.*;
	public class collectiosTest
	{
		public static void main(String[] args)
		{
			List<String> ls = new ArrayList<>();
>			
			ls.add("hi");
			ls.add("hello");
			ls.add("good");
			System.out.println(ls);
>
			//reverse the List
			Collections.reverse(ls);
			System.out.println(ls);
>
			//swap the specific elems in the list
			Collections.swap(ls,1,2);
			System.out.println(ls);
>
			//shuffle the elems in the list
			Collections.shuffle(ls);
			System.out.println(ls);
		}
	}


synchronizedXXX(Collections<T> cl):用于将集合包装成线程安全的集合。
